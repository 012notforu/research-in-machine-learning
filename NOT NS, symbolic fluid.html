<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Symbolic Navier-Stokes Fluid</title>
  <link rel="icon" href="data:," />
  <style>
    html, body, #root { height: 100%; margin: 0 }
    body { background: #0a0a0f; color: #e1e8f0; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif }
    .container { max-width: 1200px; margin: 0 auto; padding: 16px }
    .panel { background:#12121a; border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:12px }
    .controls input, .controls select { width: 100% }
  </style>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const SymbolicNavierStokes = () => {
      const canvasRef = useRef(null);
      const animationRef = useRef(null);
      const [isRunning, setIsRunning] = useState(false);
      
      const [params, setParams] = useState({
        gamma: 0.15, alpha: 0.8, beta: 0.9, convection: 0.3, dt: 0.016, Re_s: 50
      });
      
      const gridSize = 64;
      const [grid, setGrid] = useState(null);
      const [metrics, setMetrics] = useState({
        energy: 0, vorticity: 0, maxGradient: 0, circulation: 0
      });
      
      const initializeField = useCallback(() => {
        const newGrid = {
          theta: Array(gridSize).fill().map(() => Array(gridSize).fill(0)),
          velocity: Array(gridSize).fill().map(() => Array(gridSize).fill(0)),
          vorticity: Array(gridSize).fill().map(() => Array(gridSize).fill(0)),
          pressure: Array(gridSize).fill().map(() => Array(gridSize).fill(0)),
          prevTheta: Array(gridSize).fill().map(() => Array(gridSize).fill(0))
        };
        
        const centerX = gridSize / 2;
        const centerY = gridSize / 2;
        
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const dx = i - centerX;
            const dy = j - centerY;
            const r = Math.sqrt(dx*dx + dy*dy);
            const angle = Math.atan2(dy, dx);
            
            const vortexStr = 8.0;
            const vortex = vortexStr * Math.exp(-r*r / 100) * Math.sin(2*angle);
            const noise = 0.3 * (Math.random() - 0.5);
            
            newGrid.theta[i][j] = vortex + noise;
            newGrid.prevTheta[i][j] = newGrid.theta[i][j];
          }
        }
        
        setGrid(newGrid);
      }, []);
      
      const evolveField = useCallback(() => {
        if (!grid) return;
        
        const { theta, velocity, vorticity, pressure, prevTheta } = grid;
        const newTheta = theta.map(row => [...row]);
        const newVelocity = velocity.map(row => [...row]);
        const newVorticity = vorticity.map(row => [...row]);
        const newPressure = pressure.map(row => [...row]);
        
        let totalEnergy = 0;
        let totalVorticity = 0;
        let maxGrad = 0;
        let circulation = 0;
        
        for (let i = 1; i < gridSize - 1; i++) {
          for (let j = 1; j < gridSize - 1; j++) {
            const dtheta_dx = (theta[i+1][j] - theta[i-1][j]) / 2;
            const dtheta_dy = (theta[i][j+1] - theta[i][j-1]) / 2;
            
            const u = dtheta_dx;
            const v = dtheta_dy;
            newVelocity[i][j] = Math.sqrt(u*u + v*v);
            
            const d2theta_dx2 = theta[i+1][j] - 2*theta[i][j] + theta[i-1][j];
            const d2theta_dy2 = theta[i][j+1] - 2*theta[i][j] + theta[i][j-1];
            const laplacian = d2theta_dx2 + d2theta_dy2;
            
            const convective = params.convection * (u * dtheta_dx + v * dtheta_dy);
            
            const coherenceTension = params.alpha * Math.sin(theta[i][j]);
            newPressure[i][j] = -coherenceTension;
            
            const vorticityVal = dtheta_dy - dtheta_dx;
            newVorticity[i][j] = vorticityVal;
            
            const energy = 0.5 * (u*u + v*v) + coherenceTension;
            totalEnergy += energy;
            totalVorticity += Math.abs(vorticityVal);
            maxGrad = Math.max(maxGrad, Math.sqrt(u*u + v*v));
            circulation += vorticityVal;
          }
        }
        
        for (let i = 1; i < gridSize - 1; i++) {
          for (let j = 1; j < gridSize - 1; j++) {
            const d2theta_dx2 = theta[i+1][j] - 2*theta[i][j] + theta[i-1][j];
            const d2theta_dy2 = theta[i][j+1] - 2*theta[i][j] + theta[i][j-1];
            const laplacian = d2theta_dx2 + d2theta_dy2;
            
            const dtheta_dx = (theta[i+1][j] - theta[i-1][j]) / 2;
            const dtheta_dy = (theta[i][j+1] - theta[i][j-1]) / 2;
            const convective = params.convection * (dtheta_dx * dtheta_dx + dtheta_dy * dtheta_dy);
            
            const coherenceTension = params.alpha * Math.sin(theta[i][j]);
            
            const rhs = -coherenceTension + params.gamma * laplacian - convective;
            newTheta[i][j] = theta[i][j] + params.dt * rhs;
            
            // Bounds checking to prevent NaN/Inf
            if (isNaN(newTheta[i][j]) || !isFinite(newTheta[i][j])) {
              newTheta[i][j] = theta[i][j];
            }
            newTheta[i][j] = Math.max(-10, Math.min(10, newTheta[i][j]));
            
            newGrid.prevTheta[i][j] = theta[i][j];
          }
        }
        
        setGrid({
          theta: newTheta,
          velocity: newVelocity,
          vorticity: newVorticity,
          pressure: newPressure,
          prevTheta: newGrid.prevTheta
        });
        
        setMetrics({
          energy: totalEnergy / (gridSize * gridSize),
          vorticity: totalVorticity / (gridSize * gridSize),
          maxGradient: maxGrad,
          circulation: circulation
        });
      }, [grid, params]);
      
      const renderCanvas = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas || !grid) return;
        
        const ctx = canvas.getContext('2d');
        canvas.width = 512;
        canvas.height = 512;
        
        const cellSize = canvas.width / gridSize;
        
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        for (let i = 0; i < gridSize; i++) {
          for (let j = 0; j < gridSize; j++) {
            const px = i * cellSize;
            const py = j * cellSize;
            
            const theta = grid.theta[i][j];
            const velocity = grid.velocity[i][j];
            const vorticity = grid.vorticity[i][j];
            
            const hue = ((theta + Math.PI) / (2 * Math.PI)) * 360;
            const saturation = 80;
            const lightness = 30 + Math.min(40, velocity * 10);
            
            ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            ctx.fillRect(px, py, cellSize, cellSize);
            
            if (velocity > 0.1) {
              const arrowLength = Math.min(cellSize * 0.3, velocity * 5);
              const angle = Math.atan2(grid.theta[i][j+1] - grid.theta[i][j-1], grid.theta[i+1][j] - grid.theta[i-1][j]);
              
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.moveTo(px + cellSize/2, py + cellSize/2);
              ctx.lineTo(
                px + cellSize/2 + arrowLength * Math.cos(angle),
                py + cellSize/2 + arrowLength * Math.sin(angle)
              );
              ctx.stroke();
            }
          }
        }
      }, [grid]);
      
      useEffect(() => {
        if (isRunning) {
          const animate = () => {
            if (isRunning) {
              evolveField();
              requestAnimationFrame(animate);
            }
          };
          requestAnimationFrame(animate);
        }
      }, [isRunning]);
      
      useEffect(() => {
        renderCanvas();
      }, [renderCanvas]);
      
      useEffect(() => {
        initializeField();
      }, [initializeField]);
      
      const currentReynolds = params.Re_s * (1 - params.beta);
      
      return (
        <div className="container">
          <div className="panel" style={{marginBottom:12}}>
            <h1>ðŸŒŠ Symbolic Navier-Stokes Fluid</h1>
            <p>Non-Newtonian symbolic fluid dynamics with coherence tension and convective turbulence.</p>
            <div style={{ display:'flex', gap:8, alignItems:'center', flexWrap:'wrap', marginTop:8 }}>
              <button onClick={()=>setIsRunning(r=>!r)}>{isRunning? 'Pause':'Play'}</button>
              <button onClick={initializeField}>Reset</button>
              <span>Re_s = {currentReynolds.toFixed(1)}</span>
              <span>Energy: {metrics.energy.toFixed(3)}</span>
            </div>
          </div>
          
          <div style={{ display:'grid', gridTemplateColumns:'1fr 300px', gap:12 }}>
            <div className="panel">
              <canvas ref={canvasRef} style={{ width:'100%', height:'512px', border:'1px solid #333', borderRadius:8 }} />
              <p style={{ fontSize:12, marginTop:8, textAlign:'center' }}>
                <span style={{color:'#ff6b6b'}}>Red/Blue = vorticity</span>, 
                <span style={{color:'white'}}> White arrows = velocity</span>
              </p>
            </div>
            
            <div className="panel">
              <h3>SCNS Parameters</h3>
              <div style={{ fontSize:12 }}>
                <label>Symbolic Viscosity (Î³): {params.gamma.toFixed(3)}
                  <input type="range" min="0.01" max="0.5" step="0.01" value={params.gamma} onChange={e=>setParams(p=>({...p, gamma:parseFloat(e.target.value)}))} />
                </label>
                <label>Coherence Tension (Î±): {params.alpha.toFixed(3)}
                  <input type="range" min="0" max="2" step="0.05" value={params.alpha} onChange={e=>setParams(p=>({...p, alpha:parseFloat(e.target.value)}))} />
                </label>
                <label>Convection Strength: {params.convection.toFixed(3)}
                  <input type="range" min="0" max="1" step="0.05" value={params.convection} onChange={e=>setParams(p=>({...p, convection:parseFloat(e.target.value)}))} />
                </label>
                <label>Inertia Damping (Î²): {params.beta.toFixed(3)}
                  <input type="range" min="0.1" max="2" step="0.05" value={params.beta} onChange={e=>setParams(p=>({...p, beta:parseFloat(e.target.value)}))} />
                </label>
              </div>
              
              <div style={{ marginTop:12, padding:8, background:'#1a1a2e', borderRadius:8 }}>
                <h4 style={{ fontSize:12, fontWeight:'bold', marginBottom:8 }}>System Status</h4>
                <div style={{ fontSize:10 }}>
                  <div>Regime: {currentReynolds < 20 ? 'Laminar' : currentReynolds < 100 ? 'Transitional' : 'Turbulent'}</div>
                  <div>Circulation: {metrics.circulation.toFixed(4)}</div>
                  <div>Energy Flux: {(metrics.energy / (params.gamma + 0.001)).toFixed(2)}</div>
                </div>
              </div>
              
              <div style={{ marginTop:8, padding:8, background:'#1e3a8a', borderRadius:8 }}>
                <h4 style={{ fontSize:12, fontWeight:'bold', marginBottom:8 }}>The SCNS Equation</h4>
                <div style={{ fontSize:10, fontFamily:'monospace' }}>
                  âˆ‚Î¸/âˆ‚t + (âˆ‡Î¸Â·âˆ‡)Î¸ = -V'(Î¸) + Î³âˆ‡Â²Î¸
                </div>
                <div style={{ fontSize:10, marginTop:4 }}>
                  Where Î¸ is symbolic phase, V'(Î¸) is coherence potential, 
                  and the convective term creates symbolic turbulence.
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<SymbolicNavierStokes />);
  </script>
</body>
</html>
