<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wave-Spatial Intelligence System</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            padding: 20px;
            margin: 0;
            overflow-x: auto;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 2px solid #333;
            padding-bottom: 15px;
        }
        .system-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .panel {
            background: #1a1a1a;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 15px;
            height: 500px;
            overflow: hidden;
        }
        .wave-panel {
            border-color: #444;
        }
        .spatial-panel {
            border-color: #555;
        }
        canvas {
            background: #000;
            border: 1px solid #333;
            border-radius: 4px;
        }
        .wave-canvas {
            width: 100%;
            height: 100px;
        }
        .spatial-canvas {
            width: 100%;
            height: 300px;
            cursor: crosshair;
        }
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            margin: 10px 0;
        }
        button {
            background: #333;
            color: #00ff00;
            border: 1px solid #555;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        button:hover {
            background: #444;
        }
        .running {
            background: #2a4a2a !important;
            color: #8aff8a !important;
        }
        .status {
            background: #0a2a0a;
            border: 1px solid #333;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            text-align: center;
            font-size: 11px;
        }
        .metrics {
            font-size: 10px;
            color: #888;
            margin: 5px 0;
        }
        .state-display {
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            margin: 8px 0;
            color: #ffff00;
        }
        .log {
            height: 80px;
            overflow-y: auto;
            font-size: 9px;
            background: #0a0a0a;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #333;
            margin-top: 10px;
        }
        /* Symbol decoding styles - FIXED SCROLLING */
        .symbol-panel {
            grid-column: 1 / -1;
            height: 300px;
            margin-top: 20px;
            border-color: #666;
        }
        .symbol-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin: 10px 0;
        }
        .symbol-box {
            border: 1px solid #333;
            padding: 10px;
            border-radius: 4px;
        }
        .ascii-box {
            background: #0a1a0a;
        }
        .glyph-box {
            background: #1a1a0a;
        }
        .neural-box {
            background: #1a0a1a;
        }
        /* KEY FIX: Proper scrollable output areas */
        .output-area {
            height: 100px;
            overflow-y: scroll;
            overflow-x: hidden;
            background: #000;
            padding: 8px;
            border-radius: 3px;
            border: 1px solid #222;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 11px;
            resize: vertical;
        }
        .ascii-output {
            color: #44ff44;
        }
        .glyph-output {
            color: #ffff44;
            font-size: 14px;
            line-height: 1.4;
        }
        .neural-canvas {
            width: 100%;
            height: 100px;
        }
        .small-controls {
            margin-top: 5px;
            font-size: 9px;
            color: #888;
        }
        .small-btn {
            font-size: 8px;
            padding: 2px 6px;
            margin: 1px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåäüß† Wave-Spatial Intelligence System</h1>
            <div class="status" id="systemStatus">System Ready</div>
        </div>

        <div class="system-grid">
            <!-- Wave Chamber -->
            <div class="panel wave-panel">
                <h3>üåä Wave Chamber</h3>
                <div class="status running">Auto-Running</div>
                
                <canvas id="waveCanvas" class="wave-canvas" width="400" height="100"></canvas>
                
                <div class="state-display" id="waveState">012</div>
                
                <div class="metrics">
                    Resonance: <span id="resonance">0.00</span> | 
                    Cycles: <span id="cycles">0</span> | 
                    Time: <span id="time">0.0</span>s
                </div>
                
                <div class="controls">
                    <button id="toggleBtn" onclick="toggleAuto()">‚è∏Ô∏è Pause</button>
                    <button onclick="stepWave()">üîÑ Step</button>
                    <button onclick="resetWave()">üîÑ Reset</button>
                </div>
                
                <div class="log" id="waveLog">Wave Chamber initialized...</div>
            </div>

            <!-- Spatial Grid -->
            <div class="panel spatial-panel">
                <h3>üß† Spatial Intelligence</h3>
                <div class="status running">Learning Active</div>
                
                <canvas id="spatialCanvas" class="spatial-canvas" width="400" height="300"></canvas>
                
                <div class="metrics">
                    Active: <span id="activeCells">0</span> | 
                    Memory: <span id="memory">0%</span> | 
                    IQ: <span id="iq">0</span> | 
                    Inputs: <span id="inputs">0</span>
                </div>
                
                <div class="controls">
                    <button onclick="toggleLearning()">üß† Learning: ON</button>
                    <button onclick="clearGrid()">üßπ Clear</button>
                    <button onclick="analyzeGrid()">üìä Analyze</button>
                </div>
                
                <div class="log" id="spatialLog">Spatial grid ready...</div>
            </div>
        </div>

        <!-- Symbol Decoding Panel -->
        <div class="panel symbol-panel">
            <h3>üî§ Symbol Decoding Layer</h3>
            <div class="status running">Translating cognitive states</div>
            
            <div class="symbol-grid">
                <!-- ASCII Output -->
                <div class="symbol-box ascii-box">
                    <h4 style="color: #44ff44; margin: 0 0 8px 0;">ASCII Stream</h4>
                    <div id="asciiOutput" class="output-area ascii-output">Ready...</div>
                    <div class="small-controls">
                        Chars: <span id="asciiCount">0</span>
                        <button class="small-btn" onclick="scrollToBottom('asciiOutput')">‚¨áÔ∏è</button>
                        <button class="small-btn" onclick="clearASCII()">Clear</button>
                    </div>
                </div>

                <!-- Glyph Patterns -->
                <div class="symbol-box glyph-box">
                    <h4 style="color: #ffff44; margin: 0 0 8px 0;">Glyph Patterns</h4>
                    <div id="glyphOutput" class="output-area glyph-output">‚ßó ‚óê ‚óë</div>
                    <div class="small-controls">
                        Symbols: <span id="glyphCount">0</span> | Entropy: <span id="entropy">0.0</span>
                        <button class="small-btn" onclick="scrollToBottom('glyphOutput')">‚¨áÔ∏è</button>
                        <button class="small-btn" onclick="clearGlyphs()">Clear</button>
                    </div>
                </div>

                <!-- Neural Feedback -->
                <div class="symbol-box neural-box">
                    <h4 style="color: #ff44ff; margin: 0 0 8px 0;">Neural Feedback</h4>
                    <canvas id="neuralCanvas" class="neural-canvas" width="220" height="100"></canvas>
                    <div class="small-controls">
                        Feedback: <span id="feedbackLevel">0.0</span> | Loops: <span id="loopCount">0</span>
                    </div>
                </div>
            </div>

            <div class="controls">
                <button onclick="toggleSymbols()" id="symbolToggle">üî§ Symbols: ON</button>
                <button onclick="analyzeSymbols()">üìä Analyze</button>
                <button onclick="exportData()">üíæ Export</button>
            </div>

            <div class="log" id="symbolLog">Symbol decoder ready...</div>
        </div>
    </div>

    <script>
        // Simple, working wave-spatial system - back to basics!
        class WaveSpatialSystem {
            constructor() {
                console.log('Starting Wave-Spatial System...');
                
                // Wave chamber
                this.waveCanvas = document.getElementById('waveCanvas');
                this.waveCtx = this.waveCanvas.getContext('2d');
                this.waveTime = 0;
                this.waveState = [0, 1, 2];
                this.resonanceLevel = 0;
                this.cycles = 0;
                this.autoRunning = true;
                
                // Spatial grid
                this.spatialCanvas = document.getElementById('spatialCanvas');
                this.spatialCtx = this.spatialCanvas.getContext('2d');
                this.gridWidth = 20;
                this.gridHeight = 15;
                this.cellSize = 20;
                this.grid = this.initGrid();
                this.totalInputs = 0;
                this.spatialMemory = 0;
                this.spatialIQ = 0;
                this.learningEnabled = true;
                
                // Symbol decoding
                this.symbolsEnabled = true;
                this.asciiCount = 0;
                this.glyphCount = 0;
                this.entropy = 0;
                this.feedbackLevel = 0;
                this.loopCount = 0;
                
                // Neural feedback
                this.neuralCanvas = document.getElementById('neuralCanvas');
                this.neuralCtx = this.neuralCanvas.getContext('2d');
                
                // Symbol mappings
                this.asciiMap = this.buildAsciiMap();
                this.glyphSymbols = ['‚óê', '‚óë', '‚óí', '‚óì', '‚óè', '‚óã', '‚óÜ', '‚óá', '‚ñ†', '‚ñ°', '‚ñ≤', '‚ñ≥', '‚ñº', '‚ñΩ', '‚òÖ', '‚òÜ', '‚¨¢', '‚¨°', '‚ßó', '‚ßñ'];
                
                // Start the system
                this.start();
                
                // Initial logs
                this.log('wave', 'Wave chamber online - generating interference patterns');
                this.log('spatial', 'Spatial grid initialized - ready for learning');
                this.log('symbol', 'Symbol decoder active - ready to translate');
                
                console.log('System fully initialized and running!');
            }

            buildAsciiMap() {
                const map = new Map();
                const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.,!? \n';
                
                let charIndex = 0;
                for (let a = 0; a < 3; a++) {
                    for (let b = 0; b < 3; b++) {
                        for (let c = 0; c < 3; c++) {
                            const key = `${a}${b}${c}`;
                            map.set(key, chars[charIndex % chars.length]);
                            charIndex++;
                        }
                    }
                }
                return map;
            }

            initGrid() {
                const grid = [];
                for (let y = 0; y < this.gridHeight; y++) {
                    const row = [];
                    for (let x = 0; x < this.gridWidth; x++) {
                        row.push({
                            state: [0, 0, 0],
                            memory: [0, 0, 0],
                            count: 0
                        });
                    }
                    grid.push(row);
                }
                return grid;
            }

            // Main loop - this is what makes everything work
            start() {
                setInterval(() => {
                    if (this.autoRunning) {
                        this.stepWave();
                    }
                    this.renderSpatial();
                    this.renderNeural();
                    this.updateDisplays();
                }, 200); // 5 FPS
            }

            // Wave physics
            stepWave() {
                this.waveTime += 0.1;
                
                const wave1 = Math.sin(this.waveTime * 1.0);
                const wave2 = Math.sin(this.waveTime * 1.5 + Math.PI/3);
                const wave3 = Math.sin(this.waveTime * 2.0 + Math.PI*2/3);
                
                this.resonanceLevel = Math.abs(wave1 * wave2 * wave3);
                
                if (this.resonanceLevel > 0.7) {
                    this.triggerResonance();
                }
                
                this.drawWave();
            }

            triggerResonance() {
                this.cycles++;
                
                this.waveState = [
                    Math.floor(Math.random() * 3),
                    Math.floor(Math.random() * 3),
                    Math.floor(Math.random() * 3)
                ];
                
                this.sendToSpatial(this.waveState, this.resonanceLevel);
                this.log('wave', `Resonance! State: [${this.waveState.join(',')}]`);
            }

            sendToSpatial(state, level) {
                if (!this.learningEnabled) return;
                
                this.totalInputs++;
                
                const x = Math.floor((state[0] + state[1] * 3 + state[2] * 9) % this.gridWidth);
                const y = Math.floor((state[0] * 2 + state[1] + state[2] * 4) % this.gridHeight);
                
                this.activateArea(x, y, state, level);
                this.updateSpatialMetrics();
                this.processSymbols(state, level);
                
                this.log('spatial', `Learning at (${x},${y}) from [${state.join(',')}]`);
            }

            activateArea(centerX, centerY, state, intensity) {
                const radius = 2;
                
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        const dist = Math.sqrt((x - centerX)**2 + (y - centerY)**2);
                        
                        if (dist <= radius) {
                            const strength = Math.exp(-dist / radius) * intensity;
                            const cell = this.grid[y][x];
                            
                            for (let i = 0; i < 3; i++) {
                                const target = state[i] / 2.0;
                                cell.state[i] += (target - cell.state[i]) * strength * 0.5;
                                cell.memory[i] = cell.memory[i] * 0.95 + cell.state[i] * 0.05;
                            }
                            
                            cell.count++;
                        }
                    }
                }
            }

            // Symbol processing - FIXED to handle scrolling properly
            processSymbols(state, level) {
                if (!this.symbolsEnabled) return;
                
                // Calculate entropy
                let totalEnergy = 0;
                let energyDist = [0, 0, 0];
                
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        const cell = this.grid[y][x];
                        for (let i = 0; i < 3; i++) {
                            energyDist[i] += cell.state[i];
                            totalEnergy += cell.state[i];
                        }
                    }
                }
                
                if (totalEnergy > 0) {
                    for (let i = 0; i < 3; i++) {
                        energyDist[i] /= totalEnergy;
                    }
                }
                
                this.entropy = 0;
                for (let val of energyDist) {
                    if (val > 0) {
                        this.entropy -= val * Math.log2(val);
                    }
                }
                
                // Generate ASCII
                const ternary = energyDist.map(energy => {
                    if (energy > 0.5) return 2;
                    else if (energy > 0.25) return 1;
                    else return 0;
                });
                
                const key = ternary.join('');
                const asciiChar = this.asciiMap.get(key) || ' ';
                
                // Add to ASCII output - FIXED SCROLLING
                this.appendToOutput('asciiOutput', asciiChar);
                this.asciiCount++;
                
                // Generate glyph
                const entropyIndex = Math.floor(this.entropy * 5) % this.glyphSymbols.length;
                const glyph = this.glyphSymbols[entropyIndex];
                
                // Add to glyph output - FIXED SCROLLING  
                this.appendToOutput('glyphOutput', glyph + ' ');
                this.glyphCount++;
                
                // Update feedback
                this.feedbackLevel = this.entropy * level;
                if (this.feedbackLevel > 0.8) {
                    this.loopCount++;
                }
            }

            // FIXED: Proper append function with working scrolling
            appendToOutput(elementId, text) {
                const element = document.getElementById(elementId);
                
                // Check if user is at bottom before adding content
                const wasAtBottom = element.scrollTop >= (element.scrollHeight - element.clientHeight - 10);
                
                // Add the new text
                element.textContent += text;
                
                // Add line breaks for readability
                if (elementId === 'asciiOutput' && this.asciiCount % 50 === 0) {
                    element.textContent += '\n';
                }
                if (elementId === 'glyphOutput' && this.glyphCount % 15 === 0) {
                    element.textContent += '\n';
                }
                
                // Keep content manageable
                if (element.textContent.length > 3000) {
                    element.textContent = element.textContent.slice(-2000);
                }
                
                // Only auto-scroll if user was already at the bottom
                if (wasAtBottom) {
                    element.scrollTop = element.scrollHeight;
                }
            }

            updateSpatialMetrics() {
                let activeCells = 0;
                let totalMemory = 0;
                
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        const cell = this.grid[y][x];
                        if (Math.max(...cell.state) > 0.2) activeCells++;
                        totalMemory += Math.max(...cell.memory);
                    }
                }
                
                this.spatialMemory = (totalMemory / (this.gridWidth * this.gridHeight)) * 100;
                this.spatialIQ = Math.floor(this.spatialMemory / 10);
            }

            // Rendering functions
            drawWave() {
                const ctx = this.waveCtx;
                const width = this.waveCanvas.width;
                const height = this.waveCanvas.height;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                const colors = ['#ff4444', '#44ff44', '#4444ff'];
                const frequencies = [1.0, 1.5, 2.0];
                
                for (let w = 0; w < 3; w++) {
                    ctx.strokeStyle = colors[w];
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    
                    for (let x = 0; x < width; x++) {
                        const t = this.waveTime - (x / width) * 4;
                        const y = height/2 + Math.sin(t * frequencies[w]) * height/6;
                        
                        if (x === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    
                    ctx.stroke();
                }
                
                if (this.resonanceLevel > 0.7) {
                    ctx.fillStyle = '#ffff00';
                    ctx.fillRect(width - 20, 10, 15, 15);
                }
            }

            renderSpatial() {
                const ctx = this.spatialCtx;
                const width = this.spatialCanvas.width;
                const height = this.spatialCanvas.height;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        const cell = this.grid[y][x];
                        const px = x * this.cellSize;
                        const py = y * this.cellSize;
                        
                        const r = Math.floor(cell.state[0] * 255);
                        const g = Math.floor(cell.state[1] * 255);
                        const b = Math.floor(cell.state[2] * 255);
                        
                        const brightness = Math.max(...cell.memory) * 100;
                        
                        ctx.fillStyle = `rgb(${Math.min(r + brightness, 255)}, ${Math.min(g + brightness, 255)}, ${Math.min(b + brightness, 255)})`;
                        ctx.fillRect(px, py, this.cellSize - 1, this.cellSize - 1);
                        
                        if (Math.max(...cell.state) > 0.2) {
                            ctx.strokeStyle = '#ffff00';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(px, py, this.cellSize - 1, this.cellSize - 1);
                        }
                    }
                }
            }

            renderNeural() {
                const ctx = this.neuralCtx;
                const width = this.neuralCanvas.width;
                const height = this.neuralCanvas.height;
                
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                ctx.strokeStyle = '#ff44ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let x = 0; x < width; x++) {
                    const t = (x / width) * Math.PI * 6;
                    const amplitude = this.feedbackLevel * 0.9;
                    const y = height/2 + Math.sin(t) * amplitude * height/3;
                    
                    if (x === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                
                ctx.stroke();
            }

            updateDisplays() {
                document.getElementById('waveState').textContent = this.waveState.join('');
                document.getElementById('resonance').textContent = this.resonanceLevel.toFixed(2);
                document.getElementById('cycles').textContent = this.cycles;
                document.getElementById('time').textContent = this.waveTime.toFixed(1);
                
                const activeCells = this.countActiveCells();
                document.getElementById('activeCells').textContent = activeCells;
                document.getElementById('memory').textContent = this.spatialMemory.toFixed(0) + '%';
                document.getElementById('iq').textContent = this.spatialIQ;
                document.getElementById('inputs').textContent = this.totalInputs;
                
                document.getElementById('asciiCount').textContent = this.asciiCount;
                document.getElementById('glyphCount').textContent = this.glyphCount;
                document.getElementById('entropy').textContent = this.entropy.toFixed(2);
                document.getElementById('feedbackLevel').textContent = this.feedbackLevel.toFixed(2);
                document.getElementById('loopCount').textContent = this.loopCount;
            }

            countActiveCells() {
                let count = 0;
                for (let y = 0; y < this.gridHeight; y++) {
                    for (let x = 0; x < this.gridWidth; x++) {
                        if (Math.max(...this.grid[y][x].state) > 0.2) count++;
                    }
                }
                return count;
            }

            // Control functions
            toggleAuto() {
                this.autoRunning = !this.autoRunning;
                const btn = document.getElementById('toggleBtn');
                
                if (this.autoRunning) {
                    btn.textContent = '‚è∏Ô∏è Pause';
                    this.log('wave', 'Auto-run resumed');
                } else {
                    btn.textContent = '‚ñ∂Ô∏è Play';
                    this.log('wave', 'Auto-run paused');
                }
            }

            step() {
                this.stepWave();
                this.log('wave', 'Manual step');
            }

            reset() {
                this.waveTime = 0;
                this.cycles = 0;
                this.resonanceLevel = 0;
                this.waveState = [0, 1, 2];
                this.log('wave', 'System reset');
            }

            toggleLearning() {
                this.learningEnabled = !this.learningEnabled;
                this.log('spatial', `Learning ${this.learningEnabled ? 'enabled' : 'disabled'}`);
            }

            clearGrid() {
                this.grid = this.initGrid();
                this.totalInputs = 0;
                this.spatialMemory = 0;
                this.spatialIQ = 0;
                this.log('spatial', 'Grid cleared');
            }

            analyze() {
                const active = this.countActiveCells();
                const total = this.gridWidth * this.gridHeight;
                alert(`ANALYSIS:
Active: ${active}/${total} (${((active/total)*100).toFixed(1)}%)
Memory: ${this.spatialMemory.toFixed(1)}%
IQ: ${this.spatialIQ}
Inputs: ${this.totalInputs}
Cycles: ${this.cycles}
ASCII: ${this.asciiCount}
Glyphs: ${this.glyphCount}
Entropy: ${this.entropy.toFixed(2)}`);
                this.log('spatial', 'Analysis completed');
            }

            toggleSymbols() {
                this.symbolsEnabled = !this.symbolsEnabled;
                const btn = document.getElementById('symbolToggle');
                btn.textContent = `üî§ Symbols: ${this.symbolsEnabled ? 'ON' : 'OFF'}`;
                this.log('symbol', `Symbol generation ${this.symbolsEnabled ? 'enabled' : 'disabled'}`);
            }

            analyzeSymbols() {
                const ascii = document.getElementById('asciiOutput').textContent;
                const glyphs = document.getElementById('glyphOutput').textContent;
                alert(`SYMBOL ANALYSIS:
ASCII: ${this.asciiCount} chars
Sample: "${ascii.slice(-40)}"
Glyphs: ${this.glyphCount} symbols
Sample: ${glyphs.slice(-20)}
Entropy: ${this.entropy.toFixed(3)}
Feedback: ${this.feedbackLevel.toFixed(3)}`);
                this.log('symbol', 'Symbol analysis completed');
            }

            exportData() {
                const data = {
                    timestamp: new Date().toISOString(),
                    ascii: document.getElementById('asciiOutput').textContent,
                    glyphs: document.getElementById('glyphOutput').textContent,
                    metrics: {
                        cycles: this.cycles,
                        totalInputs: this.totalInputs,
                        spatialMemory: this.spatialMemory,
                        spatialIQ: this.spatialIQ,
                        asciiCount: this.asciiCount,
                        glyphCount: this.glyphCount,
                        entropy: this.entropy,
                        feedbackLevel: this.feedbackLevel,
                        loopCount: this.loopCount
                    }
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `wave_spatial_data_${Date.now()}.json`;
                link.click();
                
                this.log('symbol', 'Data exported successfully');
            }

            log(system, message) {
                const logId = system + 'Log';
                const logDiv = document.getElementById(logId);
                const time = new Date().toLocaleTimeString();
                logDiv.innerHTML += `<br>[${time}] ${message}`;
                logDiv.scrollTop = logDiv.scrollHeight;
            }
        }

        // Global system instance
        let system = null;

        // Control functions - FIXED to handle timing issues
        function toggleAuto() {
            console.log('toggleAuto called');
            if (system && system.toggleAuto) {
                system.toggleAuto();
            } else {
                console.log('System not ready yet');
            }
        }

        function stepWave() {
            console.log('stepWave called');
            if (system && system.step) {
                system.step();
            } else {
                console.log('System not ready yet');
            }
        }

        function resetWave() {
            console.log('resetWave called');
            if (system && system.reset) {
                system.reset();
            } else {
                console.log('System not ready yet');
            }
        }

        function toggleLearning() {
            console.log('toggleLearning called');
            if (system && system.toggleLearning) {
                system.toggleLearning();
            } else {
                console.log('System not ready yet');
            }
        }

        function clearGrid() {
            console.log('clearGrid called');
            if (system && system.clearGrid) {
                system.clearGrid();
            } else {
                console.log('System not ready yet');
            }
        }

        function analyzeGrid() {
            console.log('analyzeGrid called');
            if (system && system.analyze) {
                system.analyze();
            } else {
                console.log('System not ready yet');
            }
        }

        function toggleSymbols() {
            console.log('toggleSymbols called');
            if (system && system.toggleSymbols) {
                system.toggleSymbols();
            } else {
                console.log('System not ready yet');
            }
        }

        function analyzeSymbols() {
            console.log('analyzeSymbols called');
            if (system && system.analyzeSymbols) {
                system.analyzeSymbols();
            } else {
                console.log('System not ready yet');
            }
        }

        function exportData() {
            console.log('exportData called');
            if (system && system.exportData) {
                system.exportData();
            } else {
                console.log('System not ready yet');
            }
        }

        // Utility functions for output control
        function scrollToBottom(elementId) {
            const element = document.getElementById(elementId);
            if (element) {
                element.scrollTop = element.scrollHeight;
            }
        }

        function clearASCII() {
            document.getElementById('asciiOutput').textContent = 'Cleared - ready for new input...';
            if (system) system.asciiCount = 0;
        }

        function clearGlyphs() {
            document.getElementById('glyphOutput').textContent = 'Cleared - ready for new symbols...';
            if (system) system.glyphCount = 0;
        }

        // Initialize the system when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM loaded, starting system...');
            
            try {
                system = new WaveSpatialSystem();
                document.getElementById('systemStatus').textContent = 'Wave-Spatial System Online';
                document.getElementById('systemStatus').classList.add('running');
                
                console.log('System started successfully!');
                
            } catch (error) {
                console.error('System failed to start:', error);
                document.getElementById('systemStatus').textContent = 'System Error - Check Console';
            }
        });
    </script>
</body>
</html>
