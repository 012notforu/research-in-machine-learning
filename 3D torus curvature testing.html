<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Torus Curvature Testing</title>
  <link rel="icon" href="data:," />
  <style>
    html, body, #root { height: 100%; margin: 0 }
    body { background: #0a0a0f; color: #e1e8f0; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif }
    .container { max-width: 1200px; margin: 0 auto; padding: 16px }
    .panel { background:#12121a; border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:12px }
    .controls input, .controls select { width: 100% }
  </style>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;
    const THREE_NS = window.THREE;

    const clamp01 = (x) => Math.min(1, Math.max(0, x));
    const mod = (n, m) => ((n % m) + m) % m;

    const Physics3DTorus = () => {
      const [params, setParams] = useState({
        nx: 24, ny: 24, nz: 24,
        dx: 0.2, dy: 0.2, dz: 0.2, dt: 0.002,
        beta: 1.0, gamma: 0.8, lambda: 0.12, kappa: 0.015, D: 0.15,
      });
      const [torusParams, setTorusParams] = useState({
        majorRadius: 3.0, minorRadius: 1.2, majorSegments: 48, minorSegments: 24,
        mappingMode: 'both', colorIntensity: 1.0, displacementScale: 0.3, autoRotate: true, showField: true,
      });
      const [isRunning, setIsRunning] = useState(false);
      const [currentTime, setCurrentTime] = useState(0);
      const [statistics, setStatistics] = useState({ energy: 0, variance: 0, correlation: 0, curvature: 0 });

      const mountRef = useRef(null);
      const sceneRef = useRef(null);
      const rendererRef = useRef(null);
      const cameraRef = useRef(null);
      const torusRef = useRef(null);
      const materialRef = useRef(null);
      const animationRef = useRef(null);

      const fieldARef = useRef(null);
      const fieldBRef = useRef(null);
      const activeRef = useRef('A');

      const idx = useCallback((i, j, k, ny, nz) => (i * ny + j) * nz + k, []);

      const initializeField3D = useCallback(() => {
        const { nx, ny, nz } = params;
        const N = nx * ny * nz;
        const A = new Float32Array(N);
        const B = new Float32Array(N);
        for (let i = 0; i < nx; i++) {
          for (let j = 0; j < ny; j++) {
            for (let k = 0; k < nz; k++) {
              const id = idx(i, j, k, ny, nz);
              const x = (i / nx) * 2 * Math.PI;
              const y = (j / ny) * 2 * Math.PI;
              const z = (k / nz) * 2 * Math.PI;
              const mode1 = 0.3 * Math.sin(x) * Math.cos(y + z);
              const mode2 = 0.25 * Math.cos(x + y) * Math.sin(z);
              const mode3 = 0.2 * Math.sin(x + y + z);
              const noise = 0.15 * (Math.random() - 0.5);
              const cx = i - nx / 2, cy = j - ny / 2, cz = k - nz / 2;
              const r2 = (cx * cx + cy * cy + cz * cz);
              const gaussian = 0.4 * Math.exp(-r2 / (nx * nx / 16));
              const val = mode1 + mode2 + mode3 + noise + gaussian;
              A[id] = val; B[id] = val;
            }
          }
        }
        fieldARef.current = A; fieldBRef.current = B; activeRef.current = 'A'; setCurrentTime(0);
        requestAnimationFrame(() => mapFieldToTorus());
      }, [params, idx]);

      const evolveField3D = useCallback(() => {
        const { nx, ny, nz, dt, beta, gamma, lambda, kappa, D, dx, dy, dz } = params;
        const A = activeRef.current === 'A' ? fieldARef.current : fieldBRef.current;
        const P = activeRef.current === 'A' ? fieldBRef.current : fieldARef.current;
        const Nbuf = activeRef.current === 'A' ? fieldBRef.current : fieldARef.current;
        const ddx = dx * dx, ddy = dy * dy, ddz = dz * dz;
        for (let i = 0; i < nx; i++) {
          const ip = mod(i + 1, nx), im = mod(i - 1, nx);
          for (let j = 0; j < ny; j++) {
            const jp = mod(j + 1, ny), jm = mod(j - 1, ny);
            for (let k = 0; k < nz; k++) {
              const kp = mod(k + 1, nz), km = mod(k - 1, nz);
              const id = idx(i, j, k, ny, nz);
              const A_im = A[idx(im, j, k, ny, nz)], A_ip = A[idx(ip, j, k, ny, nz)];
              const A_jm = A[idx(i, jm, k, ny, nz)], A_jp = A[idx(i, jp, k, ny, nz)];
              const A_km = A[idx(i, j, km, ny, nz)], A_kp = A[idx(i, j, kp, ny, nz)];
              const A_c = A[id];
              const dAx = (A_ip - A_im) / (2 * dx);
              const dAy = (A_jp - A_jm) / (2 * dy);
              const dAz = (A_kp - A_km) / (2 * dz);
              const gradSq = dAx * dAx + dAy * dAy + dAz * dAz;
              const lap = (A_ip - 2 * A_c + A_im) / ddx + (A_jp - 2 * A_c + A_jm) / ddy + (A_kp - 2 * A_c + A_km) / ddz;
              const d2x = (A_ip - 2 * A_c + A_im) / ddx;
              const d2y = (A_jp - 2 * A_c + A_jm) / ddy;
              const d2z = (A_kp - 2 * A_c + A_km) / ddz;
              const curvature = -lambda * gradSq * (d2x + d2y + d2z);
              const noncons = kappa * A_c * (gradSq + 0.1 * Math.sin(Math.max(-2, Math.min(2, A_c))));
              const accel = (gamma / beta) * lap + (1 / beta) * (curvature + noncons) + D * lap;
              Nbuf[id] = 2 * A_c - P[id] + accel * dt * dt;
            }
          }
        }
        activeRef.current = activeRef.current === 'A' ? 'B' : 'A';
      }, [params, idx]);

      const sampleField = useCallback((u, v, w) => {
        const { nx, ny, nz } = params;
        const F = activeRef.current === 'A' ? fieldARef.current : fieldBRef.current;
        if (!F) return 0;
        const ui = Math.floor(u), vi = Math.floor(v), wi = Math.floor(w);
        const uf = u - ui, vf = v - vi, wf = w - wi;
        const i0 = mod(ui, nx), i1 = mod(ui + 1, nx);
        const j0 = mod(vi, ny), j1 = mod(vi + 1, ny);
        const k0 = mod(wi, nz), k1 = mod(wi + 1, nz);
        const c000 = F[idx(i0, j0, k0, ny, nz)];
        const c001 = F[idx(i0, j0, k1, ny, nz)];
        const c010 = F[idx(i0, j1, k0, ny, nz)];
        const c011 = F[idx(i0, j1, k1, ny, nz)];
        const c100 = F[idx(i1, j0, k0, ny, nz)];
        const c101 = F[idx(i1, j0, k1, ny, nz)];
        const c110 = F[idx(i1, j1, k0, ny, nz)];
        const c111 = F[idx(i1, j1, k1, ny, nz)];
        const c00 = c000 * (1 - uf) + c100 * uf;
        const c01 = c001 * (1 - uf) + c101 * uf;
        const c10 = c010 * (1 - uf) + c110 * uf;
        const c11 = c011 * (1 - uf) + c111 * uf;
        const c0 = c00 * (1 - vf) + c10 * vf;
        const c1 = c01 * (1 - vf) + c11 * vf;
        return c0 * (1 - wf) + c1 * wf;
      }, [params, idx]);

      const mapFieldToTorus = useCallback(() => {
        const torus = torusRef.current; if (!torus) return;
        const { nx, ny, nz } = params;
        const { mappingMode, colorIntensity, displacementScale } = torusParams;
        const geometry = torus.geometry;
        const position = geometry.attributes.position;
        const colorAttr = geometry.attributes.color;
        const normalAttr = geometry.attributes.normal;
        const F = activeRef.current === 'A' ? fieldARef.current : fieldBRef.current; if (!F) return;
        let minVal = Infinity, maxVal = -Infinity;
        for (let i = 0; i < F.length; i++) { const v = F[i]; if (v < minVal) minVal = v; if (v > maxVal) maxVal = v; }
        const range = Math.max(1e-6, maxVal - minVal);
        if (!geometry.userData.originalPositions) { geometry.userData.originalPositions = position.array.slice(); }
        const originalPositions = geometry.userData.originalPositions;
        for (let vertexIndex = 0; vertexIndex < position.count; vertexIndex++) {
          const ox = originalPositions[vertexIndex * 3 + 0];
          const oy = originalPositions[vertexIndex * 3 + 1];
          const oz = originalPositions[vertexIndex * 3 + 2];
          const rho = Math.sqrt(ox * ox + oy * oy);
          const u = Math.atan2(oy, ox);
          const v = Math.atan2(oz, rho - torusParams.majorRadius);
          const fu = ((u + Math.PI) / (2 * Math.PI)) * (nx - 1);
          const fv = ((v + Math.PI) / (2 * Math.PI)) * (ny - 1);
          const fw = ((u + Math.PI) / (2 * Math.PI)) * (nz - 1);
          const fieldValue = sampleField(fu, fv, fw);
          const normVal = (fieldValue - minVal) / range;
          if (mappingMode === 'displacement' || mappingMode === 'both') {
            const nxv = normalAttr.getX(vertexIndex);
            const nyv = normalAttr.getY(vertexIndex);
            const nzv = normalAttr.getZ(vertexIndex);
            const disp = (normVal - 0.5) * displacementScale;
            position.setXYZ(vertexIndex, ox + nxv * disp, oy + nyv * disp, oz + nzv * disp);
          } else {
            position.setXYZ(vertexIndex, ox, oy, oz);
          }
          if (mappingMode === 'color' || mappingMode === 'both') {
            const hue = (1 - normVal) * (240 / 360);
            const sat = clamp01(0.6 + 0.4 * Math.sin(normVal * Math.PI));
            const lightBase = clamp01(0.3 + normVal * 0.5);
            const light = clamp01(lightBase * torusParams.colorIntensity);
            const c = new THREE_NS.Color().setHSL(hue, sat, light);
            colorAttr.setXYZ(vertexIndex, c.r, c.g, c.b);
          }
        }
        position.needsUpdate = true; if (colorAttr) colorAttr.needsUpdate = true; geometry.computeVertexNormals();
      }, [params, torusParams, sampleField]);

      const computeStatistics = useCallback(() => {
        const { nx, ny, nz, dt, beta } = params;
        const A = activeRef.current === 'A' ? fieldARef.current : fieldBRef.current;
        const P = activeRef.current === 'A' ? fieldBRef.current : fieldARef.current; if (!A || !P) return;
        const N = nx * ny * nz;
        let mean = 0; for (let i = 0; i < N; i++) mean += A[i]; mean /= N;
        let variance = 0, energy = 0, curvature = 0;
        for (let i = 0; i < nx; i++) {
          const ip = mod(i + 1, nx), im = mod(i - 1, nx);
          for (let j = 0; j < ny; j++) {
            const jp = mod(j + 1, ny), jm = mod(j - 1, ny);
            for (let k = 0; k < nz; k++) {
              const kp = mod(k + 1, nz), km = mod(k - 1, nz);
              const idc = idx(i, j, k, ny, nz);
              const val = A[idc];
              variance += (val - mean) * (val - mean);
              const ddt = (val - P[idc]) / dt; energy += 0.5 * beta * ddt * ddt;
              const lap = (A[idx(ip, j, k, ny, nz)] + A[idx(im, j, k, ny, nz)] + A[idx(i, jp, k, ny, nz)] + A[idx(i, jm, k, ny, nz)] + A[idx(i, j, kp, ny, nz)] + A[idx(i, j, km, ny, nz)] - 6 * val);
              curvature += Math.abs(lap);
            }
          }
        }
        const corr = Math.sqrt(variance / N) * 2.0;
        setStatistics({ energy: energy / N, variance: variance / N, correlation: corr, curvature: curvature / N });
      }, [params, idx]);

      const rebuildTorusGeometry = useCallback(() => {
        if (!sceneRef.current || !materialRef.current) return;
        if (torusRef.current) { sceneRef.current.remove(torusRef.current); torusRef.current.geometry.dispose(); }
        const { majorRadius, minorRadius, majorSegments, minorSegments } = torusParams;
        const geometry = new THREE_NS.TorusGeometry(majorRadius, minorRadius, minorSegments, majorSegments);
        const colors = new Float32Array(geometry.attributes.position.count * 3);
        geometry.setAttribute('color', new THREE_NS.BufferAttribute(colors, 3));
        const torus = new THREE_NS.Mesh(geometry, materialRef.current);
        torus.castShadow = true; torus.receiveShadow = true; sceneRef.current.add(torus);
        torusRef.current = torus; geometry.computeVertexNormals(); mapFieldToTorus();
      }, [torusParams, mapFieldToTorus]);

      const initThreeJS = useCallback(() => {
        if (!mountRef.current) return () => {};
        const scene = new THREE_NS.Scene(); scene.background = new THREE_NS.Color(0x0a0a0a);
        const camera = new THREE_NS.PerspectiveCamera(60, 1, 0.1, 100); camera.position.set(8,6,8); camera.lookAt(0,0,0);
        const renderer = new THREE_NS.WebGLRenderer({ antialias: true }); renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2)); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE_NS.PCFSoftShadowMap;
        mountRef.current.appendChild(renderer.domElement);
        scene.add(new THREE_NS.AmbientLight(0x404040, 0.4)); const dir = new THREE_NS.DirectionalLight(0xffffff, 0.9); dir.position.set(10,10,5); dir.castShadow = true; scene.add(dir); const pt = new THREE_NS.PointLight(0x4080ff, 0.5, 50); pt.position.set(-5,5,-5); scene.add(pt);
        const material = new THREE_NS.MeshPhongMaterial({ vertexColors: true, shininess: 100, side: THREE_NS.DoubleSide });
        sceneRef.current = scene; rendererRef.current = renderer; cameraRef.current = camera; materialRef.current = material;
        const handleResize = () => { if (!mountRef.current) return; const w = mountRef.current.clientWidth; const h = mountRef.current.clientHeight; renderer.setSize(w,h,false); camera.aspect = w/h; camera.updateProjectionMatrix();};
        window.addEventListener('resize', handleResize); handleResize();
        let mouseDown = false, mx = 0, my = 0;
        const onMouseDown = (e)=>{ mouseDown=true; mx=e.clientX; my=e.clientY; };
        const onMouseUp = ()=>{ mouseDown=false; };
        const onMouseMove = (e)=>{ if(!mouseDown||!torusRef.current) return; const dx=e.clientX-mx; const dy=e.clientY-my; torusRef.current.rotation.y += dx*0.01; torusRef.current.rotation.x += dy*0.01; mx=e.clientX; my=e.clientY; };
        const onWheel = (e)=>{ camera.position.multiplyScalar(1 + e.deltaY*0.001); };
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('wheel', onWheel);
        rebuildTorusGeometry();
        return () => {
          window.removeEventListener('resize', handleResize);
          renderer.domElement.removeEventListener('mousedown', onMouseDown);
          renderer.domElement.removeEventListener('mouseup', onMouseUp);
          renderer.domElement.removeEventListener('mousemove', onMouseMove);
          renderer.domElement.removeEventListener('wheel', onWheel);
          if (mountRef.current && renderer.domElement) mountRef.current.removeChild(renderer.domElement);
          if (torusRef.current) torusRef.current.geometry.dispose(); if (materialRef.current) materialRef.current.dispose(); renderer.dispose();
        };
      }, [rebuildTorusGeometry]);

      const animate = useCallback(() => {
        if (isRunning) { evolveField3D(); setCurrentTime((t)=>t+params.dt); computeStatistics(); if (torusParams.showField) mapFieldToTorus(); }
        if (torusParams.autoRotate && torusRef.current) { torusRef.current.rotation.y += 0.003; torusRef.current.rotation.z += 0.001; }
        if (rendererRef.current && sceneRef.current && cameraRef.current) rendererRef.current.render(sceneRef.current, cameraRef.current);
        animationRef.current = requestAnimationFrame(animate);
      }, [isRunning, params.dt, torusParams.autoRotate, torusParams.showField, evolveField3D, computeStatistics, mapFieldToTorus]);

      useEffect(() => { initializeField3D(); }, [initializeField3D]);
      useEffect(() => { const cleanup = initThreeJS(); return cleanup; }, [initThreeJS]);
      useEffect(() => { animationRef.current = requestAnimationFrame(animate); return () => { if (animationRef.current) cancelAnimationFrame(animationRef.current); }; }, [animate]);
      useEffect(() => { rebuildTorusGeometry(); }, [torusParams.majorRadius, torusParams.minorRadius, torusParams.majorSegments, torusParams.minorSegments]);
      useEffect(() => { initializeField3D(); }, [params.nx, params.ny, params.nz]);

      return (
        <div className="container">
          <div className="panel" style={{marginBottom:12}}>
            <h1>🌌 3D Physics Torus — Living Field Visualization</h1>
            <p>3D field θ(x,y,z,t) on a lattice mapped to a torus surface (color & displacement).</p>
            <div style={{ display:'flex', gap:8, alignItems:'center', flexWrap:'wrap', marginTop:8 }}>
              <button onClick={()=>setIsRunning(r=>!r)}>{isRunning? 'Pause':'Play'}</button>
              <button onClick={initializeField3D}>Reset</button>
              <span>t = {currentTime.toFixed(2)}s</span>
              <span>Grid: {params.nx}³</span>
            </div>
          </div>
          <div style={{ display:'grid', gridTemplateColumns:'2fr 1fr', gap:12 }}>
            <div className="panel">
              <div ref={mountRef} style={{ width:'100%', height:'520px', border:'1px solid #333', borderRadius:8 }} />
            </div>
            <div className="panel">
              <h3>3D Field Stats</h3>
              <div style={{ fontSize:12 }}>
                <div>Energy: <code>{statistics.energy.toExponential(2)}</code></div>
                <div>Variance: <code>{statistics.variance.toFixed(3)}</code></div>
                <div>Correlation: <code>{statistics.correlation.toFixed(3)}</code></div>
                <div>Curvature: <code>{statistics.curvature.toExponential(2)}</code></div>
              </div>
              <hr style={{ margin:'12px 0', borderColor:'#333' }} />
              <h3>Torus Mapping</h3>
              <label>Mode
                <select value={torusParams.mappingMode} onChange={e=>setTorusParams(p=>({...p, mappingMode:e.target.value}))}>
                  <option value="color">Color</option>
                  <option value="displacement">Displacement</option>
                  <option value="both">Both</option>
                </select>
              </label>
              <label>Color Intensity
                <input type="range" min="0.1" max="2" step="0.1" value={torusParams.colorIntensity} onChange={e=>setTorusParams(p=>({...p, colorIntensity:parseFloat(e.target.value)}))} />
              </label>
              <label>Displacement
                <input type="range" min="0" max="1" step="0.05" value={torusParams.displacementScale} onChange={e=>setTorusParams(p=>({...p, displacementScale:parseFloat(e.target.value)}))} />
              </label>
              <label><input type="checkbox" checked={torusParams.autoRotate} onChange={e=>setTorusParams(p=>({...p, autoRotate:e.target.checked}))} /> Auto rotate</label>
              <hr style={{ margin:'12px 0', borderColor:'#333' }} />
              <h3>Physics</h3>
              <label>Curvature λ
                <input type="range" min="0" max="0.3" step="0.01" value={params.lambda} onChange={e=>setParams(p=>({...p, lambda:parseFloat(e.target.value)}))} />
              </label>
              <label>Gradient γ
                <input type="range" min="0.1" max="2" step="0.1" value={params.gamma} onChange={e=>setParams(p=>({...p, gamma:parseFloat(e.target.value)}))} />
              </label>
              <label>Nonconservation κ
                <input type="range" min="0" max="0.05" step="0.001" value={params.kappa} onChange={e=>setParams(p=>({...p, kappa:parseFloat(e.target.value)}))} />
              </label>
              <label>Grid Size
                <select value={params.nx} onChange={e=>{ const n=parseInt(e.target.value,10); setParams(p=>({...p, nx:n, ny:n, nz:n})) }}>
                  <option value={16}>16³ (Fast)</option>
                  <option value={24}>24³ (Good)</option>
                  <option value={32}>32³ (High)</option>
                </select>
              </label>
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Physics3DTorus />);
  </script>
</body>
</html>
