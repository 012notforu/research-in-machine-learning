<!DOCTYPE html>
<html lang="en">
<head>
<<<<<<< HEAD
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Torus Curvature Testing</title>
  <link rel="icon" href="data:," />
  <style>
    html, body, #root { height: 100%; margin: 0 }
    body { background: #0a0a0f; color: #e1e8f0; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif }
    .container { max-width: 1200px; margin: 0 auto; padding: 16px }
    .panel { background:#12121a; border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:12px }
    .controls input, .controls select { width: 100% }
  </style>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;
    const THREE_NS = window.THREE;

    const clamp01 = (x) => Math.min(1, Math.max(0, x));
    const mod = (n, m) => ((n % m) + m) % m;

    const Physics3DTorus = () => {
      const [params, setParams] = useState({
        nx: 24, ny: 24, nz: 24,
        dx: 0.2, dy: 0.2, dz: 0.2, dt: 0.002,
        beta: 1.0, gamma: 0.8, lambda: 0.12, kappa: 0.015, D: 0.15,
      });
      const [torusParams, setTorusParams] = useState({
        majorRadius: 3.0, minorRadius: 1.2, majorSegments: 48, minorSegments: 24,
        mappingMode: 'both', colorIntensity: 1.0, displacementScale: 0.3, autoRotate: true, showField: true,
      });
      const [isRunning, setIsRunning] = useState(false);
      const [currentTime, setCurrentTime] = useState(0);
      const [statistics, setStatistics] = useState({ energy: 0, variance: 0, correlation: 0, curvature: 0 });

      const mountRef = useRef(null);
      const sceneRef = useRef(null);
      const rendererRef = useRef(null);
      const cameraRef = useRef(null);
      const torusRef = useRef(null);
      const materialRef = useRef(null);
      const animationRef = useRef(null);

      const fieldARef = useRef(null);
      const fieldBRef = useRef(null);
      const activeRef = useRef('A');

      const idx = useCallback((i, j, k, ny, nz) => (i * ny + j) * nz + k, []);

      const initializeField3D = useCallback(() => {
        const { nx, ny, nz } = params;
        const N = nx * ny * nz;
        const A = new Float32Array(N);
        const B = new Float32Array(N);
        for (let i = 0; i < nx; i++) {
          for (let j = 0; j < ny; j++) {
            for (let k = 0; k < nz; k++) {
              const id = idx(i, j, k, ny, nz);
              const x = (i / nx) * 2 * Math.PI;
              const y = (j / ny) * 2 * Math.PI;
              const z = (k / nz) * 2 * Math.PI;
=======
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Physics Torus - Living Field Visualization</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #111827;
      color: #e5e7eb;
      font-family: system-ui, sans-serif;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      color: #60a5fa;
      margin: 0 0 10px;
      font-size: 2rem;
    }
    .subtitle {
      color: #9ca3af;
      margin: 0 0 30px;
    }
    .main-grid {
      display: grid;
      grid-template-columns: 3fr 1fr;
      gap: 24px;
    }
    .torus-container {
      background: #1f2937;
      padding: 16px;
      border-radius: 8px;
    }
    .torus-title {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 16px;
      color: #60a5fa;
    }
    #canvas {
      width: 100%;
      height: 384px;
      border: 1px solid #374151;
      border-radius: 4px;
      background: #0a0a0a;
    }
    .controls-row {
      margin-top: 16px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    button {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: #3b82f6;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background: #2563eb;
    }
    .reset-btn {
      background: #6b7280;
    }
    .reset-btn:hover {
      background: #4b5563;
    }
    .info-box {
      background: #374151;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      font-family: monospace;
    }
    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .control-panel {
      background: #1f2937;
      padding: 16px;
      border-radius: 8px;
    }
    .panel-title {
      font-size: 1.125rem;
      font-weight: 600;
      margin-bottom: 12px;
      color: #60a5fa;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .control-group {
      margin-bottom: 12px;
    }
    .control-group:last-child {
      margin-bottom: 0;
    }
    label {
      display: block;
      color: #9ca3af;
      margin-bottom: 4px;
      font-size: 14px;
    }
    input[type="range"] {
      width: 100%;
      margin-bottom: 4px;
    }
    select {
      width: 100%;
      background: #374151;
      color: #e5e7eb;
      border: 1px solid #4b5563;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 14px;
    }
    .value-display {
      font-size: 12px;
      color: #6b7280;
    }
    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .stat-item {
      background: #374151;
      padding: 8px;
      border-radius: 4px;
      text-align: center;
    }
    .stat-value {
      font-family: monospace;
      font-size: 12px;
      color: #60a5fa;
    }
    .stat-label {
      font-size: 10px;
      color: #9ca3af;
      margin-top: 2px;
    }
    .info-list {
      font-size: 12px;
      color: #9ca3af;
      line-height: 1.4;
    }
    .info-list li {
      margin-bottom: 4px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üåå 3D Physics Torus - Living Field Visualization</h1>
    <p class="subtitle">Complete 3D field Œ∏(x,y,z,t) mapped onto torus surface showing emergence patterns</p>
    
    <div class="main-grid">
      <!-- 3D Torus Visualization -->
      <div class="torus-container">
        <h2 class="torus-title">Living Physics Torus</h2>
        <canvas id="canvas"></canvas>
        <div class="controls-row">
          <button id="playBtn">‚ñ∂Ô∏è Play</button>
          <button id="resetBtn" class="reset-btn">üîÑ Reset</button>
          <div class="info-box" id="timeDisplay">T: 0.00s</div>
          <div class="info-box" id="gridDisplay">Grid: 24¬≥</div>
        </div>
      </div>
      
      <!-- Controls Sidebar -->
      <div class="sidebar">
        <!-- Physics Stats -->
        <div class="control-panel">
          <h3 class="panel-title">üìä 3D Field Stats</h3>
          <div class="stats-grid">
            <div class="stat-item">
              <div class="stat-value" id="energyVal">0.00e+0</div>
              <div class="stat-label">Energy</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="varianceVal">0.000</div>
              <div class="stat-label">Variance</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="correlationVal">0.000</div>
              <div class="stat-label">Correlation</div>
            </div>
            <div class="stat-item">
              <div class="stat-value" id="curvatureVal">0.00e+0</div>
              <div class="stat-label">Curvature</div>
            </div>
          </div>
        </div>
        
        <!-- Torus Parameters -->
        <div class="control-panel">
          <h3 class="panel-title">üéØ Torus Mapping</h3>
          <div class="control-group">
            <label for="mappingMode">Mapping Mode</label>
            <select id="mappingMode">
              <option value="color">Color Only</option>
              <option value="displacement">Displacement Only</option>
              <option value="both" selected>Color + Displacement</option>
            </select>
          </div>
          <div class="control-group">
            <label for="colorIntensity">Color Intensity: <span id="colorIntensityVal">1.0</span></label>
            <input type="range" id="colorIntensity" min="0.1" max="2" step="0.1" value="1.0">
          </div>
          <div class="control-group">
            <label for="displacementScale">Displacement: <span id="displacementScaleVal">0.3</span></label>
            <input type="range" id="displacementScale" min="0" max="1" step="0.05" value="0.3">
          </div>
          <div class="control-group">
            <div class="checkbox-group">
              <input type="checkbox" id="autoRotate" checked>
              <label for="autoRotate">Auto Rotate</label>
            </div>
          </div>
        </div>
        
        <!-- Physics Parameters -->
        <div class="control-panel">
          <h3 class="panel-title">‚öôÔ∏è Physics</h3>
          <div class="control-group">
            <label for="lambda">Curvature Œª: <span id="lambdaVal">0.12</span></label>
            <input type="range" id="lambda" min="0" max="0.3" step="0.01" value="0.12">
          </div>
          <div class="control-group">
            <label for="gamma">Gradient Œ≥: <span id="gammaVal">0.8</span></label>
            <input type="range" id="gamma" min="0.1" max="2" step="0.1" value="0.8">
          </div>
          <div class="control-group">
            <label for="kappa">Nonconservation Œ∫: <span id="kappaVal">0.015</span></label>
            <input type="range" id="kappa" min="0" max="0.05" step="0.001" value="0.015">
          </div>
          <div class="control-group">
            <label for="gridSize">Grid Size</label>
            <select id="gridSize">
              <option value="16">16¬≥ (Fast)</option>
              <option value="24" selected>24¬≥ (Good)</option>
              <option value="32">32¬≥ (High)</option>
            </select>
          </div>
        </div>
        
        <!-- Info -->
        <div class="control-panel">
          <h3 class="panel-title">üîß 3D ‚Üí Torus Mapping</h3>
          <ul class="info-list">
            <li>‚Ä¢ Full 3D field Œ∏(x,y,z,t) ‚Üí torus surface</li>
            <li>‚Ä¢ Trilinear interpolation for smooth mapping</li>
            <li>‚Ä¢ Real emergence patterns visible</li>
            <li>‚Ä¢ Domain formation and percolation</li>
            <li>‚Ä¢ Drag: rotate, Wheel: zoom</li>
            <li>‚Ä¢ Watch phase transitions emerge!</li>
          </ul>
        </div>
      </div>
    </div>
  </div>

  <script>
    class Physics3DTorus {
      constructor() {
        this.canvas = document.getElementById('canvas');
        this.isRunning = false;
        this.currentTime = 0;
        
        // 3D Physics parameters
        this.params = {
          nx: 24, ny: 24, nz: 24,
          dx: 0.2, dy: 0.2, dz: 0.2, dt: 0.002,
          beta: 1.0, gamma: 0.8, lambda: 0.12, kappa: 0.015, D: 0.15
        };
        
        // Torus visualization parameters
        this.torusParams = {
          majorRadius: 3.0,
          minorRadius: 1.2,
          majorSegments: 48,
          minorSegments: 24,
          mappingMode: 'both',
          colorIntensity: 1.0,
          displacementScale: 0.3,
          autoRotate: true,
          showField: true
        };
        
        // Field data
        this.field3D = null;
        this.fieldPrev3D = null;
        
        // Statistics
        this.statistics = {
          energy: 0, variance: 0, correlation: 0, curvature: 0
        };
        
        // Three.js objects
        this.scene = null;
        this.renderer = null;
        this.camera = null;
        this.torus = null;
        this.material = null;
        
        // Mouse controls
        this.mouseDown = false;
        this.mouseX = 0;
        this.mouseY = 0;
        
        this.initThreeJS();
        this.initializeField3D();
        this.bindControls();
        this.animate();
      }
      
      initThreeJS() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x0a0a0a);
        
        // Camera
        this.camera = new THREE.PerspectiveCamera(60, this.canvas.clientWidth / this.canvas.clientHeight, 0.1, 100);
        this.camera.position.set(8, 6, 8);
        this.camera.lookAt(0, 0, 0);
        
        // Renderer
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
        this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(10, 10, 5);
        directionalLight.castShadow = true;
        this.scene.add(directionalLight);
        
        const pointLight = new THREE.PointLight(0x4080ff, 0.5, 50);
        pointLight.position.set(-5, 5, -5);
        this.scene.add(pointLight);
        
        // Create torus geometry
        const geometry = new THREE.TorusGeometry(
          this.torusParams.majorRadius,
          this.torusParams.minorRadius,
          this.torusParams.minorSegments,
          this.torusParams.majorSegments
        );
        
        // Add color attribute
        const colors = new Float32Array(geometry.attributes.position.count * 3);
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        // Material with vertex colors
        this.material = new THREE.MeshPhongMaterial({
          vertexColors: true,
          shininess: 100,
          side: THREE.DoubleSide
        });
        
        // Create torus mesh
        this.torus = new THREE.Mesh(geometry, this.material);
        this.torus.castShadow = true;
        this.torus.receiveShadow = true;
        this.scene.add(this.torus);
        
        // Store original positions for displacement
        this.originalPositions = geometry.attributes.position.array.slice();
        
        // Mouse controls
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mouseup', () => this.onMouseUp());
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
      }
      
      onMouseDown(event) {
        this.mouseDown = true;
        this.mouseX = event.clientX;
        this.mouseY = event.clientY;
      }
      
      onMouseUp() {
        this.mouseDown = false;
      }
      
      onMouseMove(event) {
        if (!this.mouseDown) return;
        
        const deltaX = event.clientX - this.mouseX;
        const deltaY = event.clientY - this.mouseY;
        
        this.torus.rotation.y += deltaX * 0.01;
        this.torus.rotation.x += deltaY * 0.01;
        
        this.mouseX = event.clientX;
        this.mouseY = event.clientY;
      }
      
      onWheel(event) {
        this.camera.position.multiplyScalar(1 + event.deltaY * 0.001);
      }
      
      initializeField3D() {
        const { nx, ny, nz } = this.params;
        this.field3D = Array(nx).fill().map(() => 
          Array(ny).fill().map(() => Array(nz).fill(0))
        );
        this.fieldPrev3D = Array(nx).fill().map(() => 
          Array(ny).fill().map(() => Array(nz).fill(0))
        );
        
        // Create interesting 3D patterns that will show emergence
        for (let i = 0; i < nx; i++) {
          for (let j = 0; j < ny; j++) {
            for (let k = 0; k < nz; k++) {
              const x = (i / nx) * 2 * Math.PI;
              const y = (j / ny) * 2 * Math.PI;
              const z = (k / nz) * 2 * Math.PI;
              
              // Multiple interacting modes for rich dynamics
>>>>>>> research-Symbolic-systems
              const mode1 = 0.3 * Math.sin(x) * Math.cos(y + z);
              const mode2 = 0.25 * Math.cos(x + y) * Math.sin(z);
              const mode3 = 0.2 * Math.sin(x + y + z);
              const noise = 0.15 * (Math.random() - 0.5);
<<<<<<< HEAD
              const cx = i - nx / 2, cy = j - ny / 2, cz = k - nz / 2;
              const r2 = (cx * cx + cy * cy + cz * cz);
              const gaussian = 0.4 * Math.exp(-r2 / (nx * nx / 16));
              const val = mode1 + mode2 + mode3 + noise + gaussian;
              A[id] = val; B[id] = val;
            }
          }
        }
        fieldARef.current = A; fieldBRef.current = B; activeRef.current = 'A'; setCurrentTime(0);
        requestAnimationFrame(() => mapFieldToTorus());
      }, [params, idx]);

      const evolveField3D = useCallback(() => {
        const { nx, ny, nz, dt, beta, gamma, lambda, kappa, D, dx, dy, dz } = params;
        const A = activeRef.current === 'A' ? fieldARef.current : fieldBRef.current;
        const P = activeRef.current === 'A' ? fieldBRef.current : fieldARef.current;
        const Nbuf = activeRef.current === 'A' ? fieldBRef.current : fieldARef.current;
        const ddx = dx * dx, ddy = dy * dy, ddz = dz * dz;
        for (let i = 0; i < nx; i++) {
          const ip = mod(i + 1, nx), im = mod(i - 1, nx);
          for (let j = 0; j < ny; j++) {
            const jp = mod(j + 1, ny), jm = mod(j - 1, ny);
            for (let k = 0; k < nz; k++) {
              const kp = mod(k + 1, nz), km = mod(k - 1, nz);
              const id = idx(i, j, k, ny, nz);
              const A_im = A[idx(im, j, k, ny, nz)], A_ip = A[idx(ip, j, k, ny, nz)];
              const A_jm = A[idx(i, jm, k, ny, nz)], A_jp = A[idx(i, jp, k, ny, nz)];
              const A_km = A[idx(i, j, km, ny, nz)], A_kp = A[idx(i, j, kp, ny, nz)];
              const A_c = A[id];
              const dAx = (A_ip - A_im) / (2 * dx);
              const dAy = (A_jp - A_jm) / (2 * dy);
              const dAz = (A_kp - A_km) / (2 * dz);
              const gradSq = dAx * dAx + dAy * dAy + dAz * dAz;
              const lap = (A_ip - 2 * A_c + A_im) / ddx + (A_jp - 2 * A_c + A_jm) / ddy + (A_kp - 2 * A_c + A_km) / ddz;
              const d2x = (A_ip - 2 * A_c + A_im) / ddx;
              const d2y = (A_jp - 2 * A_c + A_jm) / ddy;
              const d2z = (A_kp - 2 * A_c + A_km) / ddz;
              const curvature = -lambda * gradSq * (d2x + d2y + d2z);
              const noncons = kappa * A_c * (gradSq + 0.1 * Math.sin(Math.max(-2, Math.min(2, A_c))));
              const accel = (gamma / beta) * lap + (1 / beta) * (curvature + noncons) + D * lap;
              Nbuf[id] = 2 * A_c - P[id] + accel * dt * dt;
            }
          }
        }
        activeRef.current = activeRef.current === 'A' ? 'B' : 'A';
      }, [params, idx]);

      const sampleField = useCallback((u, v, w) => {
        const { nx, ny, nz } = params;
        const F = activeRef.current === 'A' ? fieldARef.current : fieldBRef.current;
        if (!F) return 0;
        const ui = Math.floor(u), vi = Math.floor(v), wi = Math.floor(w);
        const uf = u - ui, vf = v - vi, wf = w - wi;
        const i0 = mod(ui, nx), i1 = mod(ui + 1, nx);
        const j0 = mod(vi, ny), j1 = mod(vi + 1, ny);
        const k0 = mod(wi, nz), k1 = mod(wi + 1, nz);
        const c000 = F[idx(i0, j0, k0, ny, nz)];
        const c001 = F[idx(i0, j0, k1, ny, nz)];
        const c010 = F[idx(i0, j1, k0, ny, nz)];
        const c011 = F[idx(i0, j1, k1, ny, nz)];
        const c100 = F[idx(i1, j0, k0, ny, nz)];
        const c101 = F[idx(i1, j0, k1, ny, nz)];
        const c110 = F[idx(i1, j1, k0, ny, nz)];
        const c111 = F[idx(i1, j1, k1, ny, nz)];
        const c00 = c000 * (1 - uf) + c100 * uf;
        const c01 = c001 * (1 - uf) + c101 * uf;
        const c10 = c010 * (1 - uf) + c110 * uf;
        const c11 = c011 * (1 - uf) + c111 * uf;
        const c0 = c00 * (1 - vf) + c10 * vf;
        const c1 = c01 * (1 - vf) + c11 * vf;
        return c0 * (1 - wf) + c1 * wf;
      }, [params, idx]);

      const mapFieldToTorus = useCallback(() => {
        const torus = torusRef.current; if (!torus) return;
        const { nx, ny, nz } = params;
        const { mappingMode, colorIntensity, displacementScale } = torusParams;
        const geometry = torus.geometry;
        const position = geometry.attributes.position;
        const colorAttr = geometry.attributes.color;
        const normalAttr = geometry.attributes.normal;
        const F = activeRef.current === 'A' ? fieldARef.current : fieldBRef.current; if (!F) return;
        let minVal = Infinity, maxVal = -Infinity;
        for (let i = 0; i < F.length; i++) { const v = F[i]; if (v < minVal) minVal = v; if (v > maxVal) maxVal = v; }
        const range = Math.max(1e-6, maxVal - minVal);
        if (!geometry.userData.originalPositions) { geometry.userData.originalPositions = position.array.slice(); }
        const originalPositions = geometry.userData.originalPositions;
        for (let vertexIndex = 0; vertexIndex < position.count; vertexIndex++) {
          const ox = originalPositions[vertexIndex * 3 + 0];
          const oy = originalPositions[vertexIndex * 3 + 1];
          const oz = originalPositions[vertexIndex * 3 + 2];
          const rho = Math.sqrt(ox * ox + oy * oy);
          const u = Math.atan2(oy, ox);
          const v = Math.atan2(oz, rho - torusParams.majorRadius);
          const fu = ((u + Math.PI) / (2 * Math.PI)) * (nx - 1);
          const fv = ((v + Math.PI) / (2 * Math.PI)) * (ny - 1);
          const fw = ((u + Math.PI) / (2 * Math.PI)) * (nz - 1);
          const fieldValue = sampleField(fu, fv, fw);
          const normVal = (fieldValue - minVal) / range;
          if (mappingMode === 'displacement' || mappingMode === 'both') {
            const nxv = normalAttr.getX(vertexIndex);
            const nyv = normalAttr.getY(vertexIndex);
            const nzv = normalAttr.getZ(vertexIndex);
            const disp = (normVal - 0.5) * displacementScale;
            position.setXYZ(vertexIndex, ox + nxv * disp, oy + nyv * disp, oz + nzv * disp);
          } else {
            position.setXYZ(vertexIndex, ox, oy, oz);
          }
          if (mappingMode === 'color' || mappingMode === 'both') {
            const hue = (1 - normVal) * (240 / 360);
            const sat = clamp01(0.6 + 0.4 * Math.sin(normVal * Math.PI));
            const lightBase = clamp01(0.3 + normVal * 0.5);
            const light = clamp01(lightBase * torusParams.colorIntensity);
            const c = new THREE_NS.Color().setHSL(hue, sat, light);
            colorAttr.setXYZ(vertexIndex, c.r, c.g, c.b);
          }
        }
        position.needsUpdate = true; if (colorAttr) colorAttr.needsUpdate = true; geometry.computeVertexNormals();
      }, [params, torusParams, sampleField]);

      const computeStatistics = useCallback(() => {
        const { nx, ny, nz, dt, beta } = params;
        const A = activeRef.current === 'A' ? fieldARef.current : fieldBRef.current;
        const P = activeRef.current === 'A' ? fieldBRef.current : fieldARef.current; if (!A || !P) return;
        const N = nx * ny * nz;
        let mean = 0; for (let i = 0; i < N; i++) mean += A[i]; mean /= N;
        let variance = 0, energy = 0, curvature = 0;
        for (let i = 0; i < nx; i++) {
          const ip = mod(i + 1, nx), im = mod(i - 1, nx);
          for (let j = 0; j < ny; j++) {
            const jp = mod(j + 1, ny), jm = mod(j - 1, ny);
            for (let k = 0; k < nz; k++) {
              const kp = mod(k + 1, nz), km = mod(k - 1, nz);
              const idc = idx(i, j, k, ny, nz);
              const val = A[idc];
              variance += (val - mean) * (val - mean);
              const ddt = (val - P[idc]) / dt; energy += 0.5 * beta * ddt * ddt;
              const lap = (A[idx(ip, j, k, ny, nz)] + A[idx(im, j, k, ny, nz)] + A[idx(i, jp, k, ny, nz)] + A[idx(i, jm, k, ny, nz)] + A[idx(i, j, kp, ny, nz)] + A[idx(i, j, km, ny, nz)] - 6 * val);
              curvature += Math.abs(lap);
            }
          }
        }
        const corr = Math.sqrt(variance / N) * 2.0;
        setStatistics({ energy: energy / N, variance: variance / N, correlation: corr, curvature: curvature / N });
      }, [params, idx]);

      const rebuildTorusGeometry = useCallback(() => {
        if (!sceneRef.current || !materialRef.current) return;
        if (torusRef.current) { sceneRef.current.remove(torusRef.current); torusRef.current.geometry.dispose(); }
        const { majorRadius, minorRadius, majorSegments, minorSegments } = torusParams;
        const geometry = new THREE_NS.TorusGeometry(majorRadius, minorRadius, minorSegments, majorSegments);
        const colors = new Float32Array(geometry.attributes.position.count * 3);
        geometry.setAttribute('color', new THREE_NS.BufferAttribute(colors, 3));
        const torus = new THREE_NS.Mesh(geometry, materialRef.current);
        torus.castShadow = true; torus.receiveShadow = true; sceneRef.current.add(torus);
        torusRef.current = torus; geometry.computeVertexNormals(); mapFieldToTorus();
      }, [torusParams, mapFieldToTorus]);

      const initThreeJS = useCallback(() => {
        if (!mountRef.current) return () => {};
        const scene = new THREE_NS.Scene(); scene.background = new THREE_NS.Color(0x0a0a0a);
        const camera = new THREE_NS.PerspectiveCamera(60, 1, 0.1, 100); camera.position.set(8,6,8); camera.lookAt(0,0,0);
        const renderer = new THREE_NS.WebGLRenderer({ antialias: true }); renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2)); renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE_NS.PCFSoftShadowMap;
        mountRef.current.appendChild(renderer.domElement);
        scene.add(new THREE_NS.AmbientLight(0x404040, 0.4)); const dir = new THREE_NS.DirectionalLight(0xffffff, 0.9); dir.position.set(10,10,5); dir.castShadow = true; scene.add(dir); const pt = new THREE_NS.PointLight(0x4080ff, 0.5, 50); pt.position.set(-5,5,-5); scene.add(pt);
        const material = new THREE_NS.MeshPhongMaterial({ vertexColors: true, shininess: 100, side: THREE_NS.DoubleSide });
        sceneRef.current = scene; rendererRef.current = renderer; cameraRef.current = camera; materialRef.current = material;
        const handleResize = () => { if (!mountRef.current) return; const w = mountRef.current.clientWidth; const h = mountRef.current.clientHeight; renderer.setSize(w,h,false); camera.aspect = w/h; camera.updateProjectionMatrix();};
        window.addEventListener('resize', handleResize); handleResize();
        let mouseDown = false, mx = 0, my = 0;
        const onMouseDown = (e)=>{ mouseDown=true; mx=e.clientX; my=e.clientY; };
        const onMouseUp = ()=>{ mouseDown=false; };
        const onMouseMove = (e)=>{ if(!mouseDown||!torusRef.current) return; const dx=e.clientX-mx; const dy=e.clientY-my; torusRef.current.rotation.y += dx*0.01; torusRef.current.rotation.x += dy*0.01; mx=e.clientX; my=e.clientY; };
        const onWheel = (e)=>{ camera.position.multiplyScalar(1 + e.deltaY*0.001); };
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('wheel', onWheel);
        rebuildTorusGeometry();
        return () => {
          window.removeEventListener('resize', handleResize);
          renderer.domElement.removeEventListener('mousedown', onMouseDown);
          renderer.domElement.removeEventListener('mouseup', onMouseUp);
          renderer.domElement.removeEventListener('mousemove', onMouseMove);
          renderer.domElement.removeEventListener('wheel', onWheel);
          if (mountRef.current && renderer.domElement) mountRef.current.removeChild(renderer.domElement);
          if (torusRef.current) torusRef.current.geometry.dispose(); if (materialRef.current) materialRef.current.dispose(); renderer.dispose();
        };
      }, [rebuildTorusGeometry]);

      const animate = useCallback(() => {
        if (isRunning) { evolveField3D(); setCurrentTime((t)=>t+params.dt); computeStatistics(); if (torusParams.showField) mapFieldToTorus(); }
        if (torusParams.autoRotate && torusRef.current) { torusRef.current.rotation.y += 0.003; torusRef.current.rotation.z += 0.001; }
        if (rendererRef.current && sceneRef.current && cameraRef.current) rendererRef.current.render(sceneRef.current, cameraRef.current);
        animationRef.current = requestAnimationFrame(animate);
      }, [isRunning, params.dt, torusParams.autoRotate, torusParams.showField, evolveField3D, computeStatistics, mapFieldToTorus]);

      useEffect(() => { initializeField3D(); }, [initializeField3D]);
      useEffect(() => { const cleanup = initThreeJS(); return cleanup; }, [initThreeJS]);
      useEffect(() => { animationRef.current = requestAnimationFrame(animate); return () => { if (animationRef.current) cancelAnimationFrame(animationRef.current); }; }, [animate]);
      useEffect(() => { rebuildTorusGeometry(); }, [torusParams.majorRadius, torusParams.minorRadius, torusParams.majorSegments, torusParams.minorSegments]);
      useEffect(() => { initializeField3D(); }, [params.nx, params.ny, params.nz]);

      return (
        <div className="container">
          <div className="panel" style={{marginBottom:12}}>
            <h1>üåå 3D Physics Torus ‚Äî Living Field Visualization</h1>
            <p>3D field Œ∏(x,y,z,t) on a lattice mapped to a torus surface (color & displacement).</p>
            <div style={{ display:'flex', gap:8, alignItems:'center', flexWrap:'wrap', marginTop:8 }}>
              <button onClick={()=>setIsRunning(r=>!r)}>{isRunning? 'Pause':'Play'}</button>
              <button onClick={initializeField3D}>Reset</button>
              <span>t = {currentTime.toFixed(2)}s</span>
              <span>Grid: {params.nx}¬≥</span>
            </div>
          </div>
          <div style={{ display:'grid', gridTemplateColumns:'2fr 1fr', gap:12 }}>
            <div className="panel">
              <div ref={mountRef} style={{ width:'100%', height:'520px', border:'1px solid #333', borderRadius:8 }} />
            </div>
            <div className="panel">
              <h3>3D Field Stats</h3>
              <div style={{ fontSize:12 }}>
                <div>Energy: <code>{statistics.energy.toExponential(2)}</code></div>
                <div>Variance: <code>{statistics.variance.toFixed(3)}</code></div>
                <div>Correlation: <code>{statistics.correlation.toFixed(3)}</code></div>
                <div>Curvature: <code>{statistics.curvature.toExponential(2)}</code></div>
              </div>
              <hr style={{ margin:'12px 0', borderColor:'#333' }} />
              <h3>Torus Mapping</h3>
              <label>Mode
                <select value={torusParams.mappingMode} onChange={e=>setTorusParams(p=>({...p, mappingMode:e.target.value}))}>
                  <option value="color">Color</option>
                  <option value="displacement">Displacement</option>
                  <option value="both">Both</option>
                </select>
              </label>
              <label>Color Intensity
                <input type="range" min="0.1" max="2" step="0.1" value={torusParams.colorIntensity} onChange={e=>setTorusParams(p=>({...p, colorIntensity:parseFloat(e.target.value)}))} />
              </label>
              <label>Displacement
                <input type="range" min="0" max="1" step="0.05" value={torusParams.displacementScale} onChange={e=>setTorusParams(p=>({...p, displacementScale:parseFloat(e.target.value)}))} />
              </label>
              <label><input type="checkbox" checked={torusParams.autoRotate} onChange={e=>setTorusParams(p=>({...p, autoRotate:e.target.checked}))} /> Auto rotate</label>
              <hr style={{ margin:'12px 0', borderColor:'#333' }} />
              <h3>Physics</h3>
              <label>Curvature Œª
                <input type="range" min="0" max="0.3" step="0.01" value={params.lambda} onChange={e=>setParams(p=>({...p, lambda:parseFloat(e.target.value)}))} />
              </label>
              <label>Gradient Œ≥
                <input type="range" min="0.1" max="2" step="0.1" value={params.gamma} onChange={e=>setParams(p=>({...p, gamma:parseFloat(e.target.value)}))} />
              </label>
              <label>Nonconservation Œ∫
                <input type="range" min="0" max="0.05" step="0.001" value={params.kappa} onChange={e=>setParams(p=>({...p, kappa:parseFloat(e.target.value)}))} />
              </label>
              <label>Grid Size
                <select value={params.nx} onChange={e=>{ const n=parseInt(e.target.value,10); setParams(p=>({...p, nx:n, ny:n, nz:n})) }}>
                  <option value={16}>16¬≥ (Fast)</option>
                  <option value={24}>24¬≥ (Good)</option>
                  <option value={32}>32¬≥ (High)</option>
                </select>
              </label>
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Physics3DTorus />);
=======
              
              // Localized perturbations to seed domain formation
              const r = Math.sqrt((i-nx/2)*(i-nx/2) + (j-ny/2)*(j-ny/2) + (k-nz/2)*(k-nz/2));
              const gaussian = 0.4 * Math.exp(-r*r / (nx*nx/16));
              
              this.field3D[i][j][k] = mode1 + mode2 + mode3 + noise + gaussian;
              this.fieldPrev3D[i][j][k] = this.field3D[i][j][k];
            }
          }
        }
        
        this.currentTime = 0;
        this.updateDisplay();
      }
      
      evolveField3D() {
        const { nx, ny, nz, dt, beta, gamma, lambda, kappa, D } = this.params;
        const newField = Array(nx).fill().map(() => 
          Array(ny).fill().map(() => Array(nz).fill(0))
        );
        
        for (let i = 0; i < nx; i++) {
          for (let j = 0; j < ny; j++) {
            for (let k = 0; k < nz; k++) {
              // Periodic boundaries
              const ip = (i + 1) % nx, im = (i - 1 + nx) % nx;
              const jp = (j + 1) % ny, jm = (j - 1 + ny) % ny;
              const kp = (k + 1) % nz, km = (k - 1 + nz) % nz;
              
              // Full 3D gradient
              const dx = (this.field3D[ip][j][k] - this.field3D[im][j][k]) / (2 * this.params.dx);
              const dy = (this.field3D[i][jp][k] - this.field3D[i][jm][k]) / (2 * this.params.dy);
              const dz = (this.field3D[i][j][kp] - this.field3D[i][j][km]) / (2 * this.params.dz);
              const gradSq = dx*dx + dy*dy + dz*dz;
              
              // 3D Laplacian
              const laplacian = (
                (this.field3D[ip][j][k] - 2*this.field3D[i][j][k] + this.field3D[im][j][k]) / (this.params.dx*this.params.dx) +
                (this.field3D[i][jp][k] - 2*this.field3D[i][j][k] + this.field3D[i][jm][k]) / (this.params.dy*this.params.dy) +
                (this.field3D[i][j][kp] - 2*this.field3D[i][j][k] + this.field3D[i][j][km]) / (this.params.dz*this.params.dz)
              );
              
              // Second derivatives for curvature
              const d2dx2 = (this.field3D[ip][j][k] - 2*this.field3D[i][j][k] + this.field3D[im][j][k]) / (this.params.dx*this.params.dx);
              const d2dy2 = (this.field3D[i][jp][k] - 2*this.field3D[i][j][k] + this.field3D[i][jm][k]) / (this.params.dy*this.params.dy);
              const d2dz2 = (this.field3D[i][j][kp] - 2*this.field3D[i][j][k] + this.field3D[i][j][km]) / (this.params.dz*this.params.dz);
              
              // 3D curvature coupling (simplified but mathematically consistent)
              const curvature = -lambda * gradSq * (d2dx2 + d2dy2 + d2dz2);
              
              // Nonconservation with 3D structure
              const noncons = kappa * this.field3D[i][j][k] * (gradSq + 0.1 * Math.sin(this.field3D[i][j][k]));
              
              // Full 3D equation of motion
              const acceleration = (gamma/beta) * laplacian + 
                                 (1/beta) * curvature + 
                                 (1/beta) * noncons + 
                                 D * laplacian;
              
              newField[i][j][k] = 2*this.field3D[i][j][k] - this.fieldPrev3D[i][j][k] + acceleration * dt * dt;
            }
          }
        }
        
        this.fieldPrev3D = this.field3D;
        this.field3D = newField;
        this.currentTime += this.params.dt;
      }
      
      mapFieldToTorus() {
        if (!this.field3D || !this.torus) return;
        
        const { nx, ny, nz } = this.params;
        const { majorRadius, minorRadius, mappingMode, colorIntensity, displacementScale } = this.torusParams;
        
        const geometry = this.torus.geometry;
        const position = geometry.attributes.position;
        const color = geometry.attributes.color;
        
        // Find field range for normalization
        let minVal = Infinity, maxVal = -Infinity;
        for (let i = 0; i < nx; i++) {
          for (let j = 0; j < ny; j++) {
            for (let k = 0; k < nz; k++) {
              minVal = Math.min(minVal, this.field3D[i][j][k]);
              maxVal = Math.max(maxVal, this.field3D[i][j][k]);
            }
          }
        }
        
        // Update each vertex on the torus
        for (let vertexIndex = 0; vertexIndex < position.count; vertexIndex++) {
          // Get original torus position
          const origX = this.originalPositions[vertexIndex * 3];
          const origY = this.originalPositions[vertexIndex * 3 + 1];
          const origZ = this.originalPositions[vertexIndex * 3 + 2];
          
          // Convert torus coordinates to field space coordinates
          const R = majorRadius;
          const r = minorRadius;
          
          // Inverse torus mapping to get (u,v) parameters
          const rho = Math.sqrt(origX*origX + origY*origY);
          const u = Math.atan2(origY, origX); // Major angle (0 to 2œÄ)
          const v = Math.atan2(origZ, rho - R); // Minor angle (0 to 2œÄ)
          
          // Map torus parameters to 3D field coordinates
          const fieldU = ((u + Math.PI) / (2 * Math.PI)) * (nx - 1);
          const fieldV = ((v + Math.PI) / (2 * Math.PI)) * (ny - 1);
          
          // Use the torus circumference position to map to Z coordinate
          const circumferencePos = (vertexIndex / position.count) * (nz - 1);
          const fieldW = circumferencePos;
          
          // Trilinear interpolation in 3D field
          const ui = Math.floor(fieldU), vi = Math.floor(fieldV), wi = Math.floor(fieldW);
          const uf = fieldU - ui, vf = fieldV - vi, wf = fieldW - wi;
          
          // Clamp indices
          const ui0 = Math.max(0, Math.min(nx-1, ui));
          const ui1 = Math.max(0, Math.min(nx-1, ui+1));
          const vi0 = Math.max(0, Math.min(ny-1, vi));
          const vi1 = Math.max(0, Math.min(ny-1, vi+1));
          const wi0 = Math.max(0, Math.min(nz-1, wi));
          const wi1 = Math.max(0, Math.min(nz-1, wi+1));
          
          // 8-point trilinear interpolation
          const c000 = this.field3D[ui0][vi0][wi0] || 0;
          const c001 = this.field3D[ui0][vi0][wi1] || 0;
          const c010 = this.field3D[ui0][vi1][wi0] || 0;
          const c011 = this.field3D[ui0][vi1][wi1] || 0;
          const c100 = this.field3D[ui1][vi0][wi0] || 0;
          const c101 = this.field3D[ui1][vi0][wi1] || 0;
          const c110 = this.field3D[ui1][vi1][wi0] || 0;
          const c111 = this.field3D[ui1][vi1][wi1] || 0;
          
          const c00 = c000*(1-uf) + c100*uf;
          const c01 = c001*(1-uf) + c101*uf;
          const c10 = c010*(1-uf) + c110*uf;
          const c11 = c011*(1-uf) + c111*uf;
          
          const c0 = c00*(1-vf) + c10*vf;
          const c1 = c01*(1-vf) + c11*vf;
          
          const fieldValue = c0*(1-wf) + c1*wf;
          
          const normalized = (fieldValue - minVal) / (maxVal - minVal);
          
          // Apply displacement mapping
          if (mappingMode === 'displacement' || mappingMode === 'both') {
            const displacement = (normalized - 0.5) * displacementScale;
            
            // Calculate surface normal direction for displacement
            const normal = new THREE.Vector3(origX, origY, origZ).normalize();
            
            position.setX(vertexIndex, origX + normal.x * displacement);
            position.setY(vertexIndex, origY + normal.y * displacement);
            position.setZ(vertexIndex, origZ + normal.z * displacement);
          } else {
            // Reset to original position
            position.setX(vertexIndex, origX);
            position.setY(vertexIndex, origY);
            position.setZ(vertexIndex, origZ);
          }
          
          // Apply color mapping
          if (mappingMode === 'color' || mappingMode === 'both') {
            // Use scientific color map: blue ‚Üí green ‚Üí yellow ‚Üí red
            const hue = (1 - normalized) * 240 / 360; // Blue to red
            const saturation = 0.8 + 0.2 * Math.sin(normalized * Math.PI);
            const lightness = 0.3 + normalized * 0.5;
            
            const hslColor = new THREE.Color().setHSL(hue, saturation, lightness * colorIntensity);
            color.setXYZ(vertexIndex, hslColor.r, hslColor.g, hslColor.b);
          }
        }
        
        position.needsUpdate = true;
        if (color) color.needsUpdate = true;
        geometry.computeVertexNormals(); // Recompute normals after displacement
      }
      
      computeStatistics() {
        if (!this.field3D) return;
        
        const { nx, ny, nz } = this.params;
        let energy = 0, variance = 0, mean = 0, curvature = 0;
        let count = 0;
        
        // First pass: mean
        for (let i = 0; i < nx; i++) {
          for (let j = 0; j < ny; j++) {
            for (let k = 0; k < nz; k++) {
              mean += this.field3D[i][j][k];
              count++;
            }
          }
        }
        mean /= count;
        
        // Second pass: variance, energy, curvature
        for (let i = 0; i < nx; i++) {
          for (let j = 0; j < ny; j++) {
            for (let k = 0; k < nz; k++) {
              const val = this.field3D[i][j][k];
              variance += (val - mean) * (val - mean);
              
              // Approximate energy density
              if (this.fieldPrev3D) {
                const ddt = (val - this.fieldPrev3D[i][j][k]) / this.params.dt;
                energy += 0.5 * this.params.beta * ddt * ddt;
              }
              
              // Approximate curvature
              if (i > 0 && i < nx-1 && j > 0 && j < ny-1 && k > 0 && k < nz-1) {
                const laplacian = (
                  this.field3D[i+1][j][k] + this.field3D[i-1][j][k] +
                  this.field3D[i][j+1][k] + this.field3D[i][j-1][k] +
                  this.field3D[i][j][k+1] + this.field3D[i][j][k-1] - 6*val
                );
                curvature += Math.abs(laplacian);
              }
            }
          }
        }
        
        this.statistics = {
          energy: energy / count,
          variance: variance / count,
          correlation: Math.sqrt(variance / count) * 2.0,
          curvature: curvature / count
        };
      }
      
      updateDisplay() {
        document.getElementById('timeDisplay').textContent = `T: ${this.currentTime.toFixed(2)}s`;
        document.getElementById('gridDisplay').textContent = `Grid: ${this.params.nx}¬≥`;
        document.getElementById('energyVal').textContent = this.statistics.energy.toExponential(2);
        document.getElementById('varianceVal').textContent = this.statistics.variance.toFixed(3);
        document.getElementById('correlationVal').textContent = this.statistics.correlation.toFixed(3);
        document.getElementById('curvatureVal').textContent = this.statistics.curvature.toExponential(2);
      }
      
      bindControls() {
        // Play/Pause button
        document.getElementById('playBtn').onclick = () => {
          this.isRunning = !this.isRunning;
          document.getElementById('playBtn').textContent = this.isRunning ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
        };
        
        // Reset button
        document.getElementById('resetBtn').onclick = () => {
          this.initializeField3D();
        };
        
        // Torus parameters
        document.getElementById('mappingMode').onchange = (e) => {
          this.torusParams.mappingMode = e.target.value;
        };
        
        document.getElementById('colorIntensity').oninput = (e) => {
          this.torusParams.colorIntensity = parseFloat(e.target.value);
          document.getElementById('colorIntensityVal').textContent = e.target.value;
        };
        
        document.getElementById('displacementScale').oninput = (e) => {
          this.torusParams.displacementScale = parseFloat(e.target.value);
          document.getElementById('displacementScaleVal').textContent = e.target.value;
        };
        
        document.getElementById('autoRotate').onchange = (e) => {
          this.torusParams.autoRotate = e.target.checked;
        };
        
        // Physics parameters
        document.getElementById('lambda').oninput = (e) => {
          this.params.lambda = parseFloat(e.target.value);
          document.getElementById('lambdaVal').textContent = e.target.value;
        };
        
        document.getElementById('gamma').oninput = (e) => {
          this.params.gamma = parseFloat(e.target.value);
          document.getElementById('gammaVal').textContent = e.target.value;
        };
        
        document.getElementById('kappa').oninput = (e) => {
          this.params.kappa = parseFloat(e.target.value);
          document.getElementById('kappaVal').textContent = e.target.value;
        };
        
        document.getElementById('gridSize').onchange = (e) => {
          const n = parseInt(e.target.value);
          this.params.nx = n;
          this.params.ny = n;
          this.params.nz = n;
          this.initializeField3D();
        };
      }
      
      animate() {
        if (this.isRunning && this.field3D && this.fieldPrev3D) {
          // Evolve physics
          this.evolveField3D();
          
          // Update statistics
          this.computeStatistics();
        }
        
        // Update torus visualization
        if (this.torusParams.showField) {
          this.mapFieldToTorus();
        }
        
        // Auto-rotate
        if (this.torusParams.autoRotate && this.torus) {
          this.torus.rotation.y += 0.003;
          this.torus.rotation.z += 0.001;
        }
        
        // Update display
        this.updateDisplay();
        
        // Render
        if (this.renderer && this.scene && this.camera) {
          this.renderer.render(this.scene, this.camera);
        }
        
        requestAnimationFrame(() => this.animate());
      }
    }
    
    // Initialize when page loads
    window.addEventListener('load', () => {
      new Physics3DTorus();
    });
>>>>>>> research-Symbolic-systems
  </script>
</body>
</html>
