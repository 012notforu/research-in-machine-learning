<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Torus Curvature Testing</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #0f0f23;
      color: #e1e8f0;
      font-family: system-ui, sans-serif;
      overflow-x: hidden;
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      color: #64ffda;
      margin-bottom: 30px;
    }
    .main {
      display: grid;
      grid-template-columns: 1fr 350px;
      gap: 20px;
    }
    .canvas-container {
      background: #1a1a2e;
      padding: 20px;
      border-radius: 12px;
      border: 1px solid #444;
      height: 600px;
    }
    #canvas {
      width: 100%;
      height: 100%;
      border: 1px solid #444;
      border-radius: 8px;
    }
    .controls {
      background: #1a1a2e;
      padding: 20px;
      border-radius: 12px;
      border: 1px solid #444;
      height: fit-content;
    }
    .control-group {
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 8px;
    }
    .control-group h3 {
      color: #64ffda;
      margin: 0 0 15px;
      font-size: 1.1rem;
    }
    label {
      display: block;
      margin-bottom: 5px;
      color: #b0bec5;
      font-size: 0.9rem;
    }
    input[type="range"] {
      width: 100%;
      margin-bottom: 5px;
    }
    button {
      background: #64ffda;
      color: #001b1f;
      border: none;
      padding: 10px 15px;
      border-radius: 6px;
      cursor: pointer;
      margin-right: 10px;
      margin-bottom: 10px;
      font-weight: 600;
    }
    button:hover {
      filter: brightness(1.1);
    }
    select {
      width: 100%;
      background: #2a2a3e;
      color: #e1e8f0;
      border: 1px solid #444;
      padding: 8px;
      border-radius: 4px;
    }
    .metrics {
      background: #1a1a2e;
      padding: 20px;
      margin-top: 20px;
      border-radius: 12px;
      border: 1px solid #444;
    }
    .metric-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }
    .metric-item {
      text-align: center;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
    }
    .metric-value {
      font-size: 1.2rem;
      font-weight: bold;
      color: #64ffda;
    }
    .metric-label {
      font-size: 0.8rem;
      color: #b0bec5;
    }
    .info {
      background: #1a1a2e;
      padding: 20px;
      margin-top: 20px;
      border-radius: 12px;
      border: 1px solid #444;
    }
    .info h3 {
      color: #64ffda;
      margin: 0 0 15px;
    }
    .info ul {
      font-size: 0.9rem;
      color: #b0bec5;
      line-height: 1.6;
    }
    .info li {
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üåä 3D Torus Curvature Testing</h1>
    
    <div class="main">
      <div class="canvas-container">
        <canvas id="canvas"></canvas>
      </div>
      
      <div class="controls">
        <div class="control-group">
          <h3>üéÆ Controls</h3>
          <button id="playBtn">‚ñ∂Ô∏è Play</button>
          <button id="pauseBtn">‚è∏Ô∏è Pause</button>
          <button id="resetBtn">üîÑ Reset</button>
        </div>
        
        <div class="control-group">
          <h3>üéØ Torus</h3>
          <label for="majorRadius">Major Radius: <span id="majorRadiusVal">3.0</span></label>
          <input type="range" id="majorRadius" min="1" max="5" value="3" step="0.1">
          
          <label for="minorRadius">Minor Radius: <span id="minorRadiusVal">1.2</span></label>
          <input type="range" id="minorRadius" min="0.5" max="2" value="1.2" step="0.1">
          
          <label for="majorSegments">Major Segments: <span id="majorSegmentsVal">48</span></label>
          <input type="range" id="majorSegments" min="16" max="128" value="48" step="4">
          
          <label for="minorSegments">Minor Segments: <span id="minorSegmentsVal">24</span></label>
          <input type="range" id="minorSegments" min="8" max="64" value="24" step="1">
          
          <label for="mappingMode">Mapping Mode:</label>
          <select id="mappingMode">
            <option value="both">Color + Displacement</option>
            <option value="color">Color Only</option>
            <option value="displacement">Displacement Only</option>
          </select>
          
          <label for="displacementScale">Displacement Scale: <span id="displacementScaleVal">0.3</span></label>
          <input type="range" id="displacementScale" min="0" max="1" value="0.3" step="0.05">
        </div>
        
        <div class="control-group">
          <h3>‚öôÔ∏è Physics</h3>
          <label for="lambda">Curvature Œª: <span id="lambdaVal">0.12</span></label>
          <input type="range" id="lambda" min="0" max="0.3" value="0.12" step="0.01">
          
          <label for="gamma">Gradient Œ≥: <span id="gammaVal">0.8</span></label>
          <input type="range" id="gamma" min="0.1" max="2" value="0.8" step="0.1">
          
          <label for="kappa">Nonconservation Œ∫: <span id="kappaVal">0.015</span></label>
          <input type="range" id="kappa" min="0" max="0.05" value="0.015" step="0.001">
          
          <label for="gridSize">Grid Size:</label>
          <select id="gridSize">
            <option value="16">16¬≥ (Fast)</option>
            <option value="24" selected>24¬≥ (Good)</option>
            <option value="32">32¬≥ (High)</option>
          </select>
        </div>
      </div>
    </div>
    
    <div class="metrics">
      <div class="metric-grid">
        <div class="metric-item">
          <div class="metric-value" id="energyVal">0.000</div>
          <div class="metric-label">Energy</div>
        </div>
        <div class="metric-item">
          <div class="metric-value" id="varianceVal">0.000</div>
          <div class="metric-label">Variance</div>
        </div>
        <div class="metric-item">
          <div class="metric-value" id="correlationVal">0.000</div>
          <div class="metric-label">Correlation</div>
        </div>
        <div class="metric-item">
          <div class="metric-value" id="curvatureVal">0.000</div>
          <div class="metric-label">Curvature</div>
        </div>
        <div class="metric-item">
          <div class="metric-value" id="timeVal">0.000</div>
          <div class="metric-label">Time</div>
        </div>
        <div class="metric-item">
          <div class="metric-value" id="topologyVal">0.000</div>
          <div class="metric-label">Topology</div>
        </div>
      </div>
    </div>
    
    <div class="info">
      <h3>üîß 3D ‚Üí Torus Mapping</h3>
      <ul>
        <li>‚Ä¢ Full 3D field Œ∏(x,y,z,t) ‚Üí torus surface with proper topology</li>
        <li>‚Ä¢ Trilinear sampling with periodic wrap in all 3 directions</li>
        <li>‚Ä¢ Displacement uses true vertex normals (stable topological mapping)</li>
        <li>‚Ä¢ Curvature coupling Œª affects field evolution and topology</li>
        <li>‚Ä¢ Topological charge computed from field winding numbers</li>
        <li>‚Ä¢ Resize-aware renderer; devicePixelRatio capped for performance</li>
        <li>‚Ä¢ Stats update live (energy/variance/correlation/curvature/topology)</li>
      </ul>
    </div>
  </div>

  <script>
    class Torus3DSim {
      constructor() {
        this.canvas = document.getElementById('canvas');
        this.isRunning = false;
        this.time = 0;
        
        // Parameters
        this.params = {
          nx: 24, ny: 24, nz: 24,
          dx: 0.2, dy: 0.2, dz: 0.2, dt: 0.002,
          beta: 1.0,
          gamma: 0.8,
          lambda: 0.12,
          kappa: 0.015,
          D: 0.15
        };
        
        this.torusParams = {
          majorRadius: 3.0,
          minorRadius: 1.2,
          majorSegments: 48,
          minorSegments: 24,
          mappingMode: 'both',
          colorIntensity: 1.0,
          displacementScale: 0.3,
          autoRotate: true
        };
        
        // Field buffers
        this.fieldA = null;
        this.fieldB = null;
        this.activeField = 'A';
        
        // Topology tracking
        this.topologyHistory = [];
        
        this.initThreeJS();
        this.initializeField();
        this.bindControls();
        this.render();
      }
      
      initThreeJS() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);
        
        // Camera
        this.camera = new THREE.PerspectiveCamera(75, this.canvas.clientWidth / this.canvas.clientHeight, 0.1, 1000);
        this.camera.position.set(8, 8, 8);
        this.camera.lookAt(0, 0, 0);
        
        // Renderer
        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });
        this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        this.scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 10, 5);
        this.scene.add(directionalLight);
        
        // Create torus
        this.createTorus();
        
        // Handle resize
        window.addEventListener('resize', () => this.onWindowResize());
      }
      
      createTorus() {
        if (this.torus) {
          this.scene.remove(this.torus);
        }
        
        const geometry = new THREE.TorusGeometry(
          this.torusParams.majorRadius,
          this.torusParams.minorRadius,
          this.torusParams.majorSegments,
          this.torusParams.minorSegments
        );
        
        // Compute vertex normals for displacement
        geometry.computeVertexNormals();
        
        // Create custom material with vertex colors
        const material = new THREE.MeshPhongMaterial({
          vertexColors: true,
          transparent: true,
          opacity: 0.9,
          wireframe: false
        });
        
        this.torus = new THREE.Mesh(geometry, material);
        this.scene.add(this.torus);
        
        // Store geometry for displacement
        this.torusGeometry = geometry;
      }
      
      idx(i, j, k) {
        return (i * this.params.ny + j) * this.params.nz + k;
      }
      
      // Trilinear interpolation for proper 3D field sampling
      sampleFieldTrilinear(x, y, z) {
        const { nx, ny, nz } = this.params;
        const field = this.activeField === 'A' ? this.fieldA : this.fieldB;
        
        // Wrap coordinates
        x = ((x % nx) + nx) % nx;
        y = ((y % ny) + ny) % ny;
        z = ((z % nz) + nz) % nz;
        
        const i0 = Math.floor(x), i1 = (i0 + 1) % nx;
        const j0 = Math.floor(y), j1 = (j0 + 1) % ny;
        const k0 = Math.floor(z), k1 = (k0 + 1) % nz;
        
        const fx = x - i0, fy = y - j0, fz = z - k0;
        
        // Get 8 corner values
        const v000 = field[this.idx(i0, j0, k0)];
        const v001 = field[this.idx(i0, j0, k1)];
        const v010 = field[this.idx(i0, j1, k0)];
        const v011 = field[this.idx(i0, j1, k1)];
        const v100 = field[this.idx(i1, j0, k0)];
        const v101 = field[this.idx(i1, j0, k1)];
        const v110 = field[this.idx(i1, j1, k0)];
        const v111 = field[this.idx(i1, j1, k1)];
        
        // Trilinear interpolation
        const c00 = v000 * (1 - fx) + v100 * fx;
        const c01 = v001 * (1 - fx) + v101 * fx;
        const c10 = v010 * (1 - fx) + v110 * fx;
        const c11 = v011 * (1 - fx) + v111 * fx;
        
        const c0 = c00 * (1 - fy) + c10 * fy;
        const c1 = c01 * (1 - fy) + c11 * fy;
        
        return c0 * (1 - fz) + c1 * fz;
      }
      
      initializeField() {
        const { nx, ny, nz } = this.params;
        const N = nx * ny * nz;
        
        this.fieldA = new Float32Array(N);
        this.fieldB = new Float32Array(N);
        
        for (let i = 0; i < nx; i++) {
          for (let j = 0; j < ny; j++) {
            for (let k = 0; k < nz; k++) {
              const id = this.idx(i, j, k);
              const x = (i / nx) * 2 * Math.PI;
              const y = (j / ny) * 2 * Math.PI;
              const z = (k / nz) * 2 * Math.PI;
              
              // Create topological structures
              const mode1 = 0.3 * Math.sin(x) * Math.cos(y + z);
              const mode2 = 0.25 * Math.cos(x + y) * Math.sin(z);
              const mode3 = 0.2 * Math.sin(x + y + z);
              const noise = 0.15 * (Math.random() - 0.5);
              
              // Add vortex-like structures
              const cx = i - nx / 2;
              const cy = j - ny / 2;
              const cz = k - nz / 2;
              const r2 = (cx * cx + cy * cy + cz * cz);
              const gaussian = 0.4 * Math.exp(-r2 / (nx * nx / 16));
              
              // Add winding number contributions
              const winding = Math.atan2(cy, cx) * 0.1;
              
              const val = mode1 + mode2 + mode3 + noise + gaussian + winding;
              this.fieldA[id] = val;
              this.fieldB[id] = val;
            }
          }
        }
        
        this.activeField = 'A';
        this.time = 0;
        this.topologyHistory = [];
        this.updateMetrics();
      }
      
      evolveField() {
        const { nx, ny, nz, dt, beta, gamma, lambda, kappa, D, dx, dy, dz } = this.params;
        const source = this.activeField === 'A' ? this.fieldA : this.fieldB;
        const target = this.activeField === 'A' ? this.fieldB : this.fieldA;
        
        for (let i = 0; i < nx; i++) {
          for (let j = 0; j < ny; j++) {
            for (let k = 0; k < nz; k++) {
              const id = this.idx(i, j, k);
              
              // Get neighbors with periodic boundary conditions
              const im1 = (i - 1 + nx) % nx;
              const ip1 = (i + 1) % nx;
              const jm1 = (j - 1 + ny) % ny;
              const jp1 = (j + 1) % ny;
              const km1 = (k - 1 + nz) % nz;
              const kp1 = (k + 1) % nz;
              
              const current = source[id];
              const dx2 = (source[this.idx(ip1, j, k)] + source[this.idx(im1, j, k)] - 2 * current) / (dx * dx);
              const dy2 = (source[this.idx(i, jp1, k)] + source[this.idx(i, jm1, k)] - 2 * current) / (dy * dy);
              const dz2 = (source[this.idx(i, j, kp1)] + source[this.idx(i, j, km1)] - 2 * current) / (dz * dz);
              
              const laplacian = dx2 + dy2 + dz2;
              
              // Curvature coupling term (topological)
              const curvatureTerm = lambda * current * current * current;
              
              // Evolution equation with topology
              const rhs = gamma * laplacian + curvatureTerm + kappa * current;
              target[id] = current + dt * rhs;
            }
          }
        }
        
        this.activeField = this.activeField === 'A' ? 'B' : 'A';
        this.time += dt;
        this.updateMetrics();
      }
      
      computeTopology() {
        const { nx, ny, nz } = this.params;
        const field = this.activeField === 'A' ? this.fieldA : this.fieldB;
        
        let totalWinding = 0;
        let vortexCount = 0;
        
        // Compute winding numbers around potential vortex centers
        for (let i = 0; i < nx; i += 4) {
          for (let j = 0; j < ny; j += 4) {
            const center = this.idx(i, j, Math.floor(nz / 2));
            let winding = 0;
            
            // Sample around a circle
            for (let theta = 0; theta < 2 * Math.PI; theta += Math.PI / 8) {
              const r = 2;
              const x = i + r * Math.cos(theta);
              const y = j + r * Math.sin(theta);
              const z = nz / 2;
              
              const val = this.sampleFieldTrilinear(x, y, z);
              winding += val;
            }
            
            if (Math.abs(winding) > 1.0) {
              vortexCount++;
              totalWinding += winding;
            }
          }
        }
        
        return {
          totalWinding: totalWinding / (nx * ny / 16),
          vortexCount: vortexCount,
          topology: Math.abs(totalWinding) / (nx * ny / 16)
        };
      }
      
      updateMetrics() {
        const { nx, ny, nz } = this.params;
        const field = this.activeField === 'A' ? this.fieldA : this.fieldB;
        const N = nx * ny * nz;
        
        let energy = 0;
        let variance = 0;
        let mean = 0;
        
        // Calculate mean
        for (let i = 0; i < N; i++) {
          mean += field[i];
        }
        mean /= N;
        
        // Calculate energy and variance
        for (let i = 0; i < N; i++) {
          const val = field[i];
          energy += val * val;
          variance += (val - mean) * (val - mean);
        }
        energy /= N;
        variance /= N;
        
        // Spatial correlation
        let correlation = 0;
        let correlationCount = 0;
        for (let i = 0; i < nx; i++) {
          for (let j = 0; j < ny; j++) {
            for (let k = 0; k < nz; k++) {
              const id = this.idx(i, j, k);
              const neighbor = this.idx((i + 1) % nx, j, k);
              correlation += field[id] * field[neighbor];
              correlationCount++;
            }
          }
        }
        correlation /= correlationCount;
        
        // Curvature (proper topological curvature)
        let curvature = 0;
        for (let i = 0; i < nx; i++) {
          for (let j = 0; j < ny; j++) {
            for (let k = 0; k < nz; k++) {
              const id = this.idx(i, j, k);
              const dx2 = (field[this.idx((i + 1) % nx, j, k)] + field[this.idx((i - 1 + nx) % nx, j, k)] - 2 * field[id]);
              const dy2 = (field[this.idx(i, (j + 1) % ny, k)] + field[this.idx(i, (j - 1 + ny) % ny, k)] - 2 * field[id]);
              const dz2 = (field[this.idx(i, j, (k + 1) % nz)] + field[this.idx(i, j, (k - 1 + nz) % nz)] - 2 * field[id]);
              curvature += Math.abs(dx2 + dy2 + dz2);
            }
          }
        }
        curvature /= N;
        
        // Compute topology
        const topology = this.computeTopology();
        
        document.getElementById('energyVal').textContent = energy.toFixed(3);
        document.getElementById('varianceVal').textContent = variance.toFixed(3);
        document.getElementById('correlationVal').textContent = correlation.toFixed(3);
        document.getElementById('curvatureVal').textContent = curvature.toFixed(3);
        document.getElementById('timeVal').textContent = this.time.toFixed(2);
        document.getElementById('topologyVal').textContent = topology.topology.toFixed(3);
        
        this.topologyHistory.push(topology.topology);
        if (this.topologyHistory.length > 100) {
          this.topologyHistory.shift();
        }
      }
      
      mapFieldToTorus() {
        if (!this.torus || !this.torusGeometry) return;
        
        const { nx, ny, nz } = this.params;
        const field = this.activeField === 'A' ? this.fieldA : this.fieldB;
        const positions = this.torusGeometry.attributes.position;
        const normals = this.torusGeometry.attributes.normal;
        
        // Ensure we have color attribute
        if (!this.torusGeometry.attributes.color) {
          this.torusGeometry.setAttribute('color', new THREE.BufferAttribute(new Float32Array(positions.count * 3), 3));
        }
        
        const colors = this.torusGeometry.attributes.color;
        
        for (let i = 0; i < positions.count; i++) {
          const vertex = new THREE.Vector3();
          vertex.fromBufferAttribute(positions, i);
          
          // Map 3D position to torus coordinates (proper topology)
          const theta = Math.atan2(vertex.y, vertex.x);
          const phi = Math.atan2(vertex.z, Math.sqrt(vertex.x * vertex.x + vertex.y * vertex.y) - this.torusParams.majorRadius);
          
          // Map to field coordinates with proper scaling
          const fi = ((theta + Math.PI) / (2 * Math.PI) * nx) % nx;
          const fj = ((phi + Math.PI) / (2 * Math.PI) * ny) % ny;
          const fk = Math.floor(nz / 2); // Use middle slice for now
          
          // Use trilinear sampling for proper field mapping
          const value = this.sampleFieldTrilinear(fi, fj, fk);
          
          // Color mapping based on field value
          const hue = ((value + 1) * 180) % 360; // Map [-1, 1] to [0, 360]
          const color = new THREE.Color().setHSL(hue / 360, 0.8, 0.5);
          
          colors.setXYZ(i, color.r, color.g, color.b);
          
          // Displacement mapping using vertex normals
          if (this.torusParams.mappingMode !== 'color' && this.torusParams.displacementScale > 0) {
            const normal = new THREE.Vector3();
            normal.fromBufferAttribute(normals, i);
            
            const displacement = value * this.torusParams.displacementScale;
            vertex.add(normal.multiplyScalar(displacement));
            positions.setXYZ(i, vertex.x, vertex.y, vertex.z);
          }
        }
        
        colors.needsUpdate = true;
        positions.needsUpdate = true;
      }
      
      render() {
        if (this.torusParams.autoRotate) {
          this.torus.rotation.x += 0.005;
          this.torus.rotation.y += 0.01;
        }
        
        this.mapFieldToTorus();
        this.renderer.render(this.scene, this.camera);
      }
      
      animate() {
        if (this.isRunning) {
          this.evolveField();
          this.render();
          requestAnimationFrame(() => this.animate());
        }
      }
      
      onWindowResize() {
        this.camera.aspect = this.canvas.clientWidth / this.canvas.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
      }
      
      bindControls() {
        // Buttons
        document.getElementById('playBtn').onclick = () => this.start();
        document.getElementById('pauseBtn').onclick = () => this.stop();
        document.getElementById('resetBtn').onclick = () => this.reset();
        
        // Torus parameters
        const torusSliders = ['majorRadius', 'minorRadius', 'majorSegments', 'minorSegments', 'displacementScale'];
        torusSliders.forEach(id => {
          const slider = document.getElementById(id);
          const display = document.getElementById(id + 'Val');
          
          slider.oninput = (e) => {
            this.torusParams[id] = parseFloat(e.target.value);
            display.textContent = e.target.value;
            if (id !== 'displacementScale') {
              this.createTorus();
            }
          };
        });
        
        // Physics parameters
        const physicsSliders = ['lambda', 'gamma', 'kappa'];
        physicsSliders.forEach(id => {
          const slider = document.getElementById(id);
          const display = document.getElementById(id + 'Val');
          
          slider.oninput = (e) => {
            this.params[id] = parseFloat(e.target.value);
            display.textContent = e.target.value;
          };
        });
        
        // Grid size
        document.getElementById('gridSize').onchange = (e) => {
          const n = parseInt(e.target.value);
          this.params.nx = n;
          this.params.ny = n;
          this.params.nz = n;
          this.initializeField();
        };
        
        // Mapping mode
        document.getElementById('mappingMode').onchange = (e) => {
          this.torusParams.mappingMode = e.target.value;
        };
      }
      
      start() {
        if (!this.isRunning) {
          this.isRunning = true;
          this.animate();
        }
      }
      
      stop() {
        this.isRunning = false;
      }
      
      reset() {
        this.stop();
        this.initializeField();
        this.render();
      }
    }
    
    // Initialize when page loads
    window.addEventListener('load', () => {
      new Torus3DSim();
    });
  </script>
</body>
</html>
