<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Symbolic Gauge Theory Lab — Emergence v2.1 (Labeled)</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%); color: #e1e8f0; line-height: 1.5;
    }
    .header { display:flex; align-items:center; justify-content:space-between; gap:16px;
      padding: 14px 18px; background: rgba(255,255,255,0.04); border-bottom:1px solid rgba(255,255,255,0.1);
      position: sticky; top:0; z-index: 50; backdrop-filter: blur(8px);
    }
    .header h1 { margin:0; font-weight:600; font-size:18px; color:#64ffda; }
    .quick-controls { display:flex; flex-wrap: wrap; align-items:center; gap:8px; }
    .qc-group { display:flex; align-items:center; gap:6px; background:rgba(0,0,0,0.25); padding:6px 8px; border-radius:8px; }
    .qc-label { font-size:11px; color:#b0bec5; }
    select, input[type="number"], .btn {
      background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.15); color:#e1e8f0;
      border-radius:6px; font-size:12px; padding:6px 8px;
    }
    .btn { cursor:pointer; }
    .btn.prim { background: linear-gradient(135deg,#64ffda 0%,#00bcd4 100%); color:#001b1f; border:none; }
    .btn.ghost { background: rgba(255,255,255,0.06); }
    .layout { display:grid; grid-template-columns: 360px 1fr; gap:1px; height: calc(100vh - 58px); }
    .panel { background: rgba(15, 15, 35, 0.95); border-right:1px solid rgba(255,255,255,0.08); overflow:auto; }
    .section { border-bottom:1px solid rgba(255,255,255,0.06); }
    .section-head { padding:12px 14px; display:flex; justify-content:space-between; align-items:center; cursor:pointer;
      background: rgba(255,255,255,0.02); color:#64ffda; font-weight:600; font-size:13px; }
    .section-body { padding:12px 14px; display:none; }
    .section-body.open { display:block; }
    .row { display:flex; align-items:center; justify-content:space-between; gap:10px; margin:8px 0; }
    .label { font-size:12px; color:#b0bec5; display:flex; gap:6px; align-items:center; }
    .sym { font-weight:700; color:#64ffda; }
    .hint { font-size:10px; color:#8ea5b0; }
    .canvas-wrap { background: rgba(26, 26, 46, 0.95); display:flex; flex-direction:column; }
    .visbar { display:flex; justify-content:space-between; align-items:center; padding:10px 14px; border-bottom:1px solid rgba(255,255,255,0.08); }
    .visbar .tabs { display:flex; gap:6px; }
    .tab { padding:6px 10px; border-radius:14px; border:1px solid rgba(100,255,218,0.35); color:#64ffda; background: rgba(100,255,218,0.08); cursor:pointer; font-size:12px; }
    .tab.active { background: rgba(100,255,218,0.28); box-shadow: 0 0 10px rgba(100,255,218,0.3); }
    .canvas-box { position:relative; flex:1; margin:14px; border-radius:12px; overflow:hidden; box-shadow: 0 8px 28px rgba(0,0,0,0.35); }
    canvas { width:100%; height:100%; background:#000; display:block; }
    .overlay { position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.6); padding:10px 12px; border-radius:8px; font-size:12px; border:1px solid rgba(100,255,218,0.25); }
    .status { display:flex; gap:18px; padding:10px 14px; border-top:1px solid rgba(255,255,255,0.08); font-size:12px; color:#b0bec5; background: rgba(0,0,0,0.35); }
    .val { color:#64ffda; font-weight:600; }
    .tip { background: rgba(100,255,218,0.06); border:1px solid rgba(100,255,218,0.2); padding:8px; border-radius:8px; font-size:11px; color:#cfe9f3; }
  </style>
</head>
<body>
  <div class="header">
    <h1>⚡ Symbolic Gauge Theory Lab — Emergence v2.1</h1>
    <div class="quick-controls">
      <div class="qc-group">
        <button id="btnPlay" class="btn prim">▶ Play</button>
        <button id="btnStep" class="btn ghost">Step</button>
        <button id="btnReset" class="btn ghost">Reset</button>
      </div>
      <div class="qc-group">
        <span class="qc-label">Grid</span>
        <select id="gridSize">
          <option value="64">64</option>
          <option value="96" selected>96</option>
          <option value="128">128</option>
          <option value="160">160</option>
        </select>
      </div>
      <div class="qc-group">
        <span class="qc-label" title="Gauge energy weight on F² term">λ (Gauge Energy)</span>
        <input id="lambda" type="number" step="0.001" value="0.003" style="width:88px" />
      </div>
      <div class="qc-group">
        <span class="qc-label" title="Simulation time step">Δt</span>
        <input id="dt" type="number" step="0.001" value="0.010" style="width:80px" />
      </div>
      <div class="qc-group">
        <span class="qc-label">Preset</span>
        <button id="presetEmergence" class="btn ghost" title="Very low λ to allow patterns to emerge">Emergence (low λ)</button>
      </div>
      <div class="qc-group">
        <span class="qc-label">Init</span>
        <select id="initSelect">
          <option value="vortex">Gauge Vortex</option>
          <option value="random">Random Gauge</option>
          <option value="waves">Gauge Waves</option>
          <option value="soliton">Topological Soliton</option>
          <option value="uniform">Uniform Field</option>
          <option value="monopole">Magnetic Monopole</option>
        </select>
      </div>
    </div>
  </div>

  <div class="layout">
    <aside class="panel">
      <!-- Parameter Legend / Labeled Controls -->
      <div class="section">
        <div class="section-head" data-target="#s-legend">Parameter Legend & Basic Controls <span>▼</span></div>
        <div class="section-body open" id="s-legend">
          <div class="tip" style="margin-bottom:10px">Hover labels for tooltips. Symbols → plain English mapping.</div>
          <div class="row"><div class="label"><span class="sym">β</span> θ inertia (mass)</div>
            <input id="beta" type="number" step="0.1" value="1.0" title="β — inertia for θ (second-order term)"/></div>
          <div class="row"><div class="label"><span class="sym">γ</span> Dθ mobility (linear flux)</div>
            <input id="gamma" type="number" step="0.1" value="0.6" title="γ — linear part of the covariant flux"/></div>
          <div class="row"><div class="label"><span class="sym">α</span> nonlinear focusing</div>
            <input id="alpha" type="number" step="0.1" value="1.1" title="α — strength of 1/|Dθ|³ focusing"/></div>
          <div class="row"><div class="label"><span class="sym">λ</span> gauge energy (F² weight)</div>
            <input id="lambda_side" type="number" step="0.001" value="0.003" title="λ — coefficient in -¼ λ F²"/></div>
          <div class="row"><div class="label"><span class="sym">ε</span> regularizer for |Dθ|</div>
            <input id="epsilon" type="number" step="0.01" value="0.10" title="ε — avoids singularities when |Dθ|≈0"/></div>
          <div class="row"><div class="label"><span class="sym">ζ</span> gauge damping (Ȧ)</div>
            <input id="zeta" type="number" step="0.01" value="0.10" title="ζ — damping on Ȧ to avoid runaway"/></div>
          <div class="row"><div class="label"><span class="sym">ν<sub>θ</sub></span> phase viscosity</div>
            <input id="nuTheta" type="number" step="0.005" value="0.015" title="νθ — Laplacian smoothing on θ"/></div>
          <div class="row"><div class="label"><span class="sym">ν<sub>A</sub></span> gauge viscosity</div>
            <input id="nuA" type="number" step="0.005" value="0.020" title="νA — Laplacian smoothing on A"/></div>
          <div class="row"><div class="label"><span class="sym">η</span> phase damping (θ̇)</div>
            <input id="eta" type="number" step="0.005" value="0.020" title="η — damping on θ̇"/></div>
          <div class="row"><div class="label"><span class="sym">Δt</span> time step</div>
            <input id="dt_side" type="number" step="0.001" value="0.010" title="time step (CFL guarded)"/></div>
          <div class="row"><div class="label"><span class="sym">S</span> init field strength</div>
            <input id="fieldStrengthParam" type="number" step="0.1" value="1.0" title="scales seeded patterns for initial conditions"/></div>
        </div>
      </div>

      <!-- Presets -->
      <div class="section">
        <div class="section-head" data-target="#s-presets">Presets <span>▼</span></div>
        <div class="section-body open" id="s-presets">
          <div class="row"><button class="btn ghost" id="presetLowLambda" title="Encourage emergence">Emergence (very low λ)</button></div>
          <div class="row" style="gap:6px; flex-wrap:wrap">
            <button class="btn ghost" id="presetEM">Electromagnetic-ish</button>
            <button class="btn ghost" id="presetYang">Yang–Mills-ish</button>
            <button class="btn ghost" id="presetTopo">Topological</button>
            <button class="btn ghost" id="presetWeak">Weak Coupling</button>
            <button class="btn ghost" id="presetStrong">Strong Coupling</button>
            <button class="btn ghost" id="presetCritical">Critical-ish</button>
          </div>
        </div>
      </div>

      <!-- Info -->
      <div class="section">
        <div class="section-head" data-target="#s-notes">Notes <span>▼</span></div>
        <div class="section-body open" id="s-notes">
          <div class="tip">
            θ evolves from the divergence of the covariant flux
            <em>J = γ·Dθ - α·Dθ/(|Dθ|²+ε²)^{3/2}</em>.
            The gauge field A obeys a damped, viscous update driven by (div F - J).
            Set λ small to let structure emerge; increase ζ or viscosities if things blow up.
          </div>
        </div>
      </div>
    </aside>

    <main class="canvas-wrap">
      <div class="visbar">
        <div class="tabs">
          <button class="tab active" data-mode="theta">θ Phase</button>
          <button class="tab" data-mode="A">A Field |A|</button>
          <button class="tab" data-mode="F">F Tensor |F₁₂|</button>
          <button class="tab" data-mode="J">J Current |J|</button>
          <button class="tab" data-mode="L">Lagrangian</button>
        </div>
        <div style="font-size:12px; color:#b0bec5">View</div>
      </div>

      <div class="canvas-box">
        <canvas id="fieldCanvas" width="1024" height="700"></canvas>
        <div class="overlay">
          <div>t: <span id="tVal" class="val">0.000</span></div>
          <div>FPS: <span id="fpsVal" class="val">--</span></div>
          <div>Gauge mode: <span class="val">U(1)</span></div>
        </div>
      </div>

      <div class="status">
        <div>Status: <span id="runStat" class="val">Paused</span></div>
        <div>Gauge Invariance (proxy): <span id="invVal" class="val">--</span></div>
        <div>Coupling: <span id="couplingVal" class="val">--</span></div>
      </div>
    </main>
  </div>

  <script>
    const $$ = (q) => document.querySelector(q);
    const $$$ = (q) => document.querySelectorAll(q);

    class GaugeLab {
      constructor() {
        this.canvas = $$('#fieldCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.gridSize = parseInt($$('#gridSize').value, 10);
        this.dx = 1.0 / this.gridSize;
        this.time = 0;
        // Parameters (defaults)
        this.beta = 1.0;     // θ inertia
        this.gamma = 0.6;    // linear mobility
        this.alpha = 1.1;    // nonlinear focusing
        this.lambda = 0.003; // gauge energy (low for emergence)
        this.epsilon = 0.10; // regularizer
        this.dt = 0.010;     // time step
        this.zeta = 0.10;    // gauge damping on Ȧ
        this.nuA = 0.020;    // gauge viscosity (Laplacian on A)
        this.nuTheta = 0.015;// phase viscosity (Laplacian on θ)
        this.eta = 0.020;    // phase damping on θ̇
        this.fieldStrengthParam = 1.0; // init scale

        this.mode = 'theta'; // visualization mode
        this.running = false;
        this.lastTS = 0; this.fps = 0;

        this._alloc();
        this.initializeField('vortex');
        this._bindUI();
        this._loop();
      }

      _alloc() {
        const N = this.gridSize;
        const Z = () => Array(N).fill(0).map(() => Array(N).fill(0));
        // primary fields
        this.theta = Z();
        this.theta_t = Z();
        this.theta_new = Z();
        this.theta_t_new = Z();
        this.Ax = Z();
        this.Ay = Z();
        this.Ax_t = Z();
        this.Ay_t = Z();
        this.Ax_new = Z();
        this.Ay_new = Z();
        // derived
        this.Dx = Z();
        this.Dy = Z();
        this.F = Z();
        this.Jx = Z();
        this.Jy = Z();
        this.Jmag = Z();
        this.Amag = Z();
        this.L = Z();
        this.Fmag = Z();
      }

      _idx(i,j){
        const N = this.gridSize; return {i: (i%N+N)%N, j: (j%N+N)%N};
      }
      _val(M,i,j){ const p=this._idx(i,j); return M[p.i][p.j]; }
      _grad(M,i,j){
        const dx = (this._val(M,i+1,j) - this._val(M,i-1,j)) / (2*this.dx);
        const dy = (this._val(M,i,j+1) - this._val(M,i,j-1)) / (2*this.dx);
        return {x:dx,y:dy};
      }
      _lap(M,i,j){
        const c = M[i][j];
        const dxx = (this._val(M,i+1,j) - 2*c + this._val(M,i-1,j)) / (this.dx*this.dx);
        const dyy = (this._val(M,i,j+1) - 2*c + this._val(M,i,j-1)) / (this.dx*this.dx);
        return dxx + dyy;
      }

      _updateParamsFromUI(){
        // Sync top-bar and side copies of same params
        const lambdaTop = parseFloat($$('#lambda').value);
        const lambdaSide = parseFloat($$('#lambda_side').value);
        const newLambda = Number.isFinite(lambdaTop) ? lambdaTop : lambdaSide;
        $$('#lambda').value = newLambda;
        $$('#lambda_side').value = newLambda;

        const dtTop = parseFloat($$('#dt').value);
        const dtSide = parseFloat($$('#dt_side').value);
        const newDt = Number.isFinite(dtTop) ? dtTop : dtSide;
        $$('#dt').value = newDt; $$('#dt_side').value = newDt;

        this.beta = parseFloat($$('#beta').value);
        this.gamma = parseFloat($$('#gamma').value);
        this.alpha = parseFloat($$('#alpha').value);
        this.lambda = newLambda;
        this.epsilon = parseFloat($$('#epsilon').value);
        this.dt = newDt;
        this.zeta = parseFloat($$('#zeta').value);
        this.nuTheta = parseFloat($$('#nuTheta').value);
        this.nuA = parseFloat($$('#nuA').value);
        this.eta = parseFloat($$('#eta').value);
        this.fieldStrengthParam = parseFloat($$('#fieldStrengthParam').value);

        // simple stability guard
        const vis = Math.max(this.nuA, this.nuTheta, 1e-6);
        const dtCFL = 0.2 * (this.dx*this.dx) / (vis + 1e-6);
        if (this.dt > dtCFL) { this.dt = dtCFL; $$('#dt').value = this.dt.toFixed(3); $$('#dt_side').value = $$('#dt').value; }
      }

      computeDerived(){
        const N = this.gridSize;
        for(let i=0;i<N;i++){
          for(let j=0;j<N;j++){
            // covariant derivatives
            const g = this._grad(this.theta,i,j);
            this.Dx[i][j] = g.x - this.Ax[i][j];
            this.Dy[i][j] = g.y - this.Ay[i][j];
          }
        }
        for(let i=0;i<N;i++){
          for(let j=0;j<N;j++){
            // field strength F12 = ∂x Ay - ∂y Ax
            const gAx = this._grad(this.Ax,i,j);
            const gAy = this._grad(this.Ay,i,j);
            const F = gAy.x - gAx.y; this.F[i][j] = F; this.Fmag[i][j] = Math.abs(F);
            // magnitudes for visuals
            this.Amag[i][j] = Math.hypot(this.Ax[i][j], this.Ay[i][j]);
          }
        }
      }

      evolve(){
        this._updateParamsFromUI();
        this.computeDerived();
        const N = this.gridSize;
        const eps2 = this.epsilon*this.epsilon;

        // Build flux J = γ Dθ - α Dθ/(|Dθ|^2+ε^2)^{3/2}
        for(let i=0;i<N;i++){
          for(let j=0;j<N;j++){
            const Dx = this.Dx[i][j], Dy = this.Dy[i][j];
            const mag2 = Dx*Dx + Dy*Dy;
            const denom = Math.pow(mag2 + eps2, 1.5);
            this.Jx[i][j] = this.gamma*Dx - this.alpha*Dx/denom;
            this.Jy[i][j] = this.gamma*Dy - this.alpha*Dy/denom;
            this.Jmag[i][j] = Math.hypot(this.Jx[i][j], this.Jy[i][j]);
          }
        }

        // Divergence of J
        const divJ = Array(N).fill(0).map(()=>Array(N).fill(0));
        for(let i=0;i<N;i++){
          for(let j=0;j<N;j++){
            const Jx_x = (this._val(this.Jx,i+1,j) - this._val(this.Jx,i-1,j)) / (2*this.dx);
            const Jy_y = (this._val(this.Jy,i,j+1) - this._val(this.Jy,i,j-1)) / (2*this.dx);
            divJ[i][j] = Jx_x + Jy_y;
          }
        }

        // θ update (second-order with damping + viscosity)
        for(let i=0;i<N;i++){
          for(let j=0;j<N;j++){
            const visc = this.nuTheta * this._lap(this.theta,i,j);
            const acc = (divJ[i][j] + visc) / this.beta - this.eta * this.theta_t[i][j];
            this.theta_t_new[i][j] = this.theta_t[i][j] + this.dt * acc;
            this.theta_new[i][j] = this.theta[i][j] + this.dt * this.theta_t_new[i][j];
            if(!Number.isFinite(this.theta_new[i][j])){ this.theta_new[i][j] = 0; this.theta_t_new[i][j] = 0; }
          }
        }

        // Gauge: div F - J drives Ȧ, with damping and viscosity
        for(let i=0;i<N;i++){
          for(let j=0;j<N;j++){
            const dFy = (this._val(this.F,i,j+1) - this._val(this.F,i,j-1)) / (2*this.dx); // ∂y F
            const dFx = (this._val(this.F,i+1,j) - this._val(this.F,i-1,j)) / (2*this.dx); // ∂x F
            const drive_x = this.lambda * ( dFy - this.Jx[i][j] );
            const drive_y = this.lambda * ( -dFx - this.Jy[i][j] );
            const viscAx = this.nuA * this._lap(this.Ax,i,j);
            const viscAy = this.nuA * this._lap(this.Ay,i,j);

            const Ax_tn = this.Ax_t[i][j] + this.dt * ( drive_x + viscAx - this.zeta * this.Ax_t[i][j] );
            const Ay_tn = this.Ay_t[i][j] + this.dt * ( drive_y + viscAy - this.zeta * this.Ay_t[i][j] );
            this.Ax_new[i][j] = this.Ax[i][j] + this.dt * Ax_tn;
            this.Ay_new[i][j] = this.Ay[i][j] + this.dt * Ay_tn;
            this.Ax_t[i][j] = Ax_tn; this.Ay_t[i][j] = Ay_tn;
            if(!Number.isFinite(this.Ax_new[i][j])) this.Ax_new[i][j] = 0;
            if(!Number.isFinite(this.Ay_new[i][j])) this.Ay_new[i][j] = 0;
          }
        }

        // swap
        [this.theta, this.theta_new] = [this.theta_new, this.theta];
        [this.theta_t, this.theta_t_new] = [this.theta_t_new, this.theta_t];
        [this.Ax, this.Ax_new] = [this.Ax_new, this.Ax];
        [this.Ay, this.Ay_new] = [this.Ay_new, this.Ay];

        // Lagrangian + invariance proxy
        let Lsum=0, Fsum=0, Jsum=0; const N2 = N*N;
        for(let i=0;i<N;i++){
          for(let j=0;j<N;j++){
            const tdot = this.theta_t[i][j];
            const D2 = this.Dx[i][j]*this.Dx[i][j] + this.Dy[i][j]*this.Dy[i][j];
            const kinetic = 0.5*this.beta*tdot*tdot;
            const covKin = -0.5*this.gamma*D2;
            const nonlinear = this.alpha / Math.pow(D2 + eps2, 1.5);
            const gaugeE = -0.25*this.lambda*this.F[i][j]*this.F[i][j];
            const viscTerms = -0.5*this.nuTheta * Math.abs(this._lap(this.theta,i,j));
            const L = kinetic + covKin + nonlinear + gaugeE + viscTerms;
            this.L[i][j] = L; Lsum += L;
            Fsum += Math.abs(this.F[i][j]);
            Jsum += this.Jmag[i][j];
          }
        }
        const avgF = Fsum/N2; const avgJ = Jsum/N2; const avgL = Lsum/N2;
        const invProxy = Math.exp(-avgF); // cheap proxy
        $$('#invVal').textContent = (invProxy*100|0) + '%';
        let coup = 'Weak'; if(avgF>0.9) coup='Strong'; else if(avgF>0.5) coup='Medium';
        $$('#couplingVal').textContent = coup;

        this.time += this.dt;
      }

      render(){
        const w = this.canvas.width, h = this.canvas.height; const img = this.ctx.createImageData(w,h); const px = img.data;
        const scaleX = w / this.gridSize, scaleY = h / this.gridSize;
        let data, mode = this.mode, type = 'phase';
        if(mode==='theta'){ data = this.theta; type='phase'; }
        else if(mode==='A'){ data = this.Amag; type='cont'; }
        else if(mode==='F'){ data = this.Fmag; type='cont'; }
        else if(mode==='J'){ data = this.Jmag; type='cont'; }
        else { data = this.L; type='cont'; }

        // range
        let min=-Math.PI, max=Math.PI;
        if(type==='cont'){
          min=Infinity; max=-Infinity;
          for(let i=0;i<this.gridSize;i++) for(let j=0;j<this.gridSize;j++){ const v=data[i][j]; if(Number.isFinite(v)){ if(v<min)min=v; if(v>max)max=v; } }
          if(min===max){ max=min+1; }
        }
        for(let y=0;y<h;y++){
          for(let x=0;x<w;x++){
            const i = Math.floor(x/scaleX), j = Math.floor(y/scaleY);
            let r,g,b;
            if(type==='phase'){
              const phase = data[i][j];
              const hue = ((phase + Math.PI) / (2*Math.PI)) * 360; // HSV→RGB
              const c=0.8*0.9, m=0.9-c; const k = (hue/60)%2; const X=c*(1-Math.abs(k-1));
              let R=0,G=0,B=0;
              if(hue<60){R=c;G=X;B=0;} else if(hue<120){R=X;G=c;B=0;} else if(hue<180){R=0;G=c;B=X;}
              else if(hue<240){R=0;G=X;B=c;} else if(hue<300){R=X;G=0;B=c;} else {R=c;G=0;B=X;}
              r=(R+m)*255; g=(G+m)*255; b=(B+m)*255;
            } else {
              const v = (data[i][j]-min)/(max-min);
              const t = Math.max(0, Math.min(1, v));
              if(mode==='A'){ r=100+t*155; g=60+t*195; b=255; }
              else if(mode==='F'){ r=255; g=(1-t)*255; b=(1-t)*120; }
              else if(mode==='J'){ r=t*255; g=255; b=120; }
              else { const mid=0.5; if(t<mid){ r=0; g=0; b=(t/mid)*255; } else { r=((t-mid)/mid)*255; g=0; b=255-((t-mid)/mid)*255; } }
            }
            const p = (y*w + x)*4; px[p]=r|0; px[p+1]=g|0; px[p+2]=b|0; px[p+3]=255;
          }
        }
        this.ctx.putImageData(img,0,0);
      }

      initializeField(kind){
        const N=this.gridSize, cx=N/2, cy=N/2; const S=this.fieldStrengthParam;
        for(let i=0;i<N;i++) for(let j=0;j<N;j++){ this.theta[i][j]=0; this.theta_t[i][j]=0; this.Ax[i][j]=0; this.Ay[i][j]=0; this.Ax_t[i][j]=0; this.Ay_t[i][j]=0; }
        if(kind==='vortex'){
          for(let i=0;i<N;i++) for(let j=0;j<N;j++){
            const x=i-cx, y=j-cy; const r=Math.hypot(x,y)+0.1; const ang=Math.atan2(y,x);
            this.theta[i][j]=ang; this.Ax[i][j]= -y/(r*r) * S; this.Ay[i][j]= x/(r*r) * S;
          }
        } else if(kind==='random'){
          for(let i=0;i<N;i++) for(let j=0;j<N;j++){
            this.theta[i][j]=(Math.random()-0.5)*2*Math.PI; this.Ax[i][j]=(Math.random()-0.5)*S; this.Ay[i][j]=(Math.random()-0.5)*S;
          }
        } else if(kind==='waves'){
          for(let i=0;i<N;i++) for(let j=0;j<N;j++){
            const x=i*this.dx, y=j*this.dx; this.theta[i][j]=Math.sin(4*Math.PI*x)*Math.cos(4*Math.PI*y);
            this.Ax[i][j]=Math.cos(4*Math.PI*x)*Math.sin(4*Math.PI*y)*S; this.Ay[i][j]=-Math.sin(4*Math.PI*x)*Math.cos(4*Math.PI*y)*S;
          }
        } else if(kind==='soliton'){
          for(let i=0;i<N;i++) for(let j=0;j<N;j++){
            const x=i-cx, y=j-cy; const r=Math.hypot(x,y); this.theta[i][j]= 2*Math.atan(r/10);
            const f= 2/(10 + r*r/10); this.Ax[i][j]= -y*f*S; this.Ay[i][j]= x*f*S;
          }
        } else if(kind==='uniform'){
          for(let i=0;i<N;i++) for(let j=0;j<N;j++){ this.theta[i][j]=0; this.Ax[i][j]=S; this.Ay[i][j]=0; }
        } else if(kind==='monopole'){
          for(let i=0;i<N;i++) for(let j=0;j<N;j++){
            const x=i-cx, y=j-cy; const r=Math.hypot(x,y)+0.1; this.theta[i][j]=Math.exp(-r/10)*Math.cos(3*Math.atan2(y,x));
            this.Ax[i][j]= x/r*S; this.Ay[i][j]= y/r*S;
          }
        }
        this.time=0;
      }

      setGridSize(N){
        const keepKind = $$('#initSelect').value;
        this.gridSize = N; this.dx = 1.0/N; this._alloc(); this.initializeField(keepKind);
      }

      _bindUI(){
        // Collapsers
        $$$('.section-head').forEach(h=>{
          h.addEventListener('click',()=>{
            const target = h.getAttribute('data-target'); const el = document.querySelector(target);
            el.classList.toggle('open');
          });
        });
        // Tabs
        $$$('.tab').forEach(t=>{
          t.addEventListener('click',()=>{ $$$('.tab').forEach(b=>b.classList.remove('active')); t.classList.add('active'); this.mode = t.getAttribute('data-mode'); });
        });
        // Buttons
        $$('#btnPlay').addEventListener('click',()=>{ this.running = !this.running; $$('#btnPlay').textContent = this.running ? '⏸ Pause' : '▶ Play'; $$('#runStat').textContent = this.running ? 'Running' : 'Paused'; });
        $$('#btnStep').addEventListener('click',()=>{ if(!this.running){ this.evolve(); this.render(); }});
        $$('#btnReset').addEventListener('click',()=>{ this.initializeField($$('#initSelect').value); });
        $$('#presetEmergence').addEventListener('click',()=>{ $$('#lambda').value='0.001'; $$('#lambda_side').value='0.001'; $$('#zeta').value='0.12'; $$('#nuA').value='0.02'; $$('#nuTheta').value='0.015'; });
        $$('#presetLowLambda').addEventListener('click',()=>{ $$('#lambda').value='0.001'; $$('#lambda_side').value='0.001'; });
        $$('#presetEM').addEventListener('click',()=>{ $$('#beta').value='1.0'; $$('#gamma').value='1.0'; $$('#alpha').value='0.2'; $$('#lambda').value='0.25'; $$('#lambda_side').value='0.25'; });
        $$('#presetYang').addEventListener('click',()=>{ $$('#beta').value='1.0'; $$('#gamma').value='0.6'; $$('#alpha').value='2.2'; $$('#lambda').value='0.5'; $$('#lambda_side').value='0.5'; });
        $$('#presetTopo').addEventListener('click',()=>{ $$('#beta').value='2.0'; $$('#gamma').value='0.4'; $$('#alpha').value='1.6'; $$('#lambda').value='0.1'; $$('#lambda_side').value='0.1'; });
        $$('#presetWeak').addEventListener('click',()=>{ $$('#alpha').value='0.3'; $$('#lambda').value='0.05'; $$('#lambda_side').value='0.05'; });
        $$('#presetStrong').addEventListener('click',()=>{ $$('#alpha').value='3.0'; $$('#lambda').value='1.0'; $$('#lambda_side').value='1.0'; });
        $$('#presetCritical').addEventListener('click',()=>{ $$('#beta').value='1.0'; $$('#gamma').value='1.0'; $$('#alpha').value='1.0'; $$('#lambda').value='0.25'; $$('#lambda_side').value='0.25'; });
        // Grid size
        $$('#gridSize').addEventListener('change',(e)=>{ this.setGridSize(parseInt(e.target.value,10)); });
        // Init select
        $$('#initSelect').addEventListener('change',()=>{ this.initializeField($$('#initSelect').value); });
        // Keep side/top sync
        ['lambda','dt'].forEach(id=>{
          $$('#'+id).addEventListener('input',()=>this._updateParamsFromUI());
        });
        ['lambda_side','dt_side','beta','gamma','alpha','epsilon','zeta','nuTheta','nuA','eta','fieldStrengthParam'].forEach(id=>{
          $$('#'+id).addEventListener('input',()=>this._updateParamsFromUI());
        });
      }

      _loop(){
        const step = (ts)=>{
          const d = ts - this.lastTS; this.fps = d>0? 1000/d : 0; this.lastTS = ts;
          if(this.running) this.evolve();
          this.render();
          $$('#tVal').textContent = this.time.toFixed(3);
          $$('#fpsVal').textContent = Math.round(this.fps);
          requestAnimationFrame(step);
        };
        requestAnimationFrame(step);
      }
    }

    // Boot
    const LAB = new GaugeLab();
  </script>
</body>
</html>
