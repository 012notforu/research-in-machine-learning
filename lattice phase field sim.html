<!DOCTYPE html>
<html lang="en">
<head>
<<<<<<< HEAD
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lattice Phase Field Simulation</title>
  <link rel="icon" href="data:," />
  <style>
    html, body, #root { height: 100%; margin: 0 }
    body { background: #0a0a0f; color: #e1e8f0; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif }
    .container { max-width: 1200px; margin: 0 auto; padding: 16px }
    .panel { background:#12121a; border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:12px }
    .controls input, .controls select { width: 100% }
  </style>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const QuantumSymbolicComplexity = () => {
      const canvasRef = useRef(null);
      const animationRef = useRef(null);
      
      const [isRunning, setIsRunning] = useState(false);
      const [time, setTime] = useState(0);
      const [field, setField] = useState(null);
      const [trailBuffer, setTrailBuffer] = useState(null);
      
      const [settings, setSettings] = useState({
        gridSize: 64,
        diffusionRate: 0.1,
        nonlinearStrength: 0.8,
        complexityThreshold: 0.7,
        showGrid: false,
        showTrails: false,
        trailDecay: 0.95,
        enableAnalysis: false,
        analysisMode: 'energy',
        showPatterns: false
      });
      
      const [complexity, setComplexity] = useState([]);
      const [entropy, setEntropy] = useState([]);
      const [circuitDepth, setCircuitDepth] = useState([]);
      const [entropySpikes, setEntropySpikes] = useState([]);
      
      const [energyHistory, setEnergyHistory] = useState([]);
      const [momentumHistory, setMomentumHistory] = useState([]);
      const [fourierSpectrum, setFourierSpectrum] = useState(null);
      const [correlationData, setCorrelationData] = useState([]);
      const [lyapunovExponent, setLyapunovExponent] = useState(0);
      const [evolutionHistory, setEvolutionHistory] = useState([]);
      
      const [detectedPatterns, setDetectedPatterns] = useState({
        spirals: [],
        waves: [],
        symmetries: [],
        topologicalCharge: 0
      });
      const [patternHistory, setPatternHistory] = useState([]);

      const getNeighbors = (x, y, grid, gridSize) => {
        return [
          grid[(x+1) % gridSize]?.[y],
          grid[x]?.[(y+1) % gridSize],
          grid[(x-1+gridSize) % gridSize]?.[y],
          grid[x]?.[(y-1+gridSize) % gridSize]
        ].filter(Boolean);
      };

      const initializeField = useCallback(() => {
        const { gridSize } = settings;
        
        const newField = Array(gridSize).fill().map(() => 
          Array(gridSize).fill().map(() => ({
            phase: Math.random() * 2 * Math.PI,
            amplitude: Math.random() * 0.5 + 0.1,
            complexity: 0
          }))
        );
        
=======
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lattice Phase Field Simulator</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      background: #0f0f23;
      color: #e1e8f0;
      font-family: system-ui, sans-serif;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      text-align: center;
      color: #64ffda;
      margin-bottom: 30px;
    }
    .main {
      display: grid;
      grid-template-columns: 1fr 300px;
      gap: 20px;
    }
    .canvas-container {
      background: #1a1a2e;
      padding: 20px;
      border-radius: 12px;
      border: 1px solid #444;
    }
    canvas {
      width: 100%;
      height: 600px;
      border: 1px solid #444;
      background: #000;
    }
    .controls {
      background: #1a1a2e;
      padding: 20px;
      border-radius: 12px;
      border: 1px solid #444;
      height: fit-content;
    }
    .control-group {
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      color: #b0bec5;
    }
    input[type="range"] {
      width: 100%;
    }
    button {
      background: #64ffda;
      color: #001b1f;
      border: none;
      padding: 10px 15px;
      border-radius: 6px;
      cursor: pointer;
      margin-right: 10px;
      margin-bottom: 10px;
    }
    .metrics {
      background: #1a1a2e;
      padding: 20px;
      margin-top: 20px;
      border-radius: 12px;
      border: 1px solid #444;
    }
    .metric-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }
    .metric-item {
      text-align: center;
      padding: 10px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 6px;
    }
    .metric-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #64ffda;
    }
    .metric-label {
      font-size: 0.8rem;
      color: #b0bec5;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üåä Lattice Phase Field Simulator</h1>
    
    <div class="main">
      <div class="canvas-container">
        <canvas id="canvas" width="800" height="600"></canvas>
      </div>
      
      <div class="controls">
        <div class="control-group">
          <button id="playBtn">‚ñ∂Ô∏è Play</button>
          <button id="pauseBtn">‚è∏Ô∏è Pause</button>
          <button id="resetBtn">üîÑ Reset</button>
        </div>
        
        <div class="control-group">
          <label for="gridSize">Grid Size: <span id="gridSizeVal">64</span></label>
          <input type="range" id="gridSize" min="32" max="128" value="64" step="8">
        </div>
        
        <div class="control-group">
          <label for="diffusionRate">Diffusion Rate: <span id="diffusionRateVal">0.1</span></label>
          <input type="range" id="diffusionRate" min="0.01" max="0.5" value="0.1" step="0.01">
        </div>
        
        <div class="control-group">
          <label for="nonlinearStrength">Nonlinear Strength: <span id="nonlinearStrengthVal">0.8</span></label>
          <input type="range" id="nonlinearStrength" min="0.1" max="2.0" value="0.8" step="0.1">
        </div>
        
        <div class="control-group">
          <label><input type="checkbox" id="showGrid"> Show Grid</label>
          <label><input type="checkbox" id="showTrails"> Show Trails</label>
        </div>
      </div>
    </div>
    
    <div class="metrics">
      <div class="metric-grid">
        <div class="metric-item">
          <div class="metric-value" id="complexityVal">0.000</div>
          <div class="metric-label">Complexity</div>
        </div>
        <div class="metric-item">
          <div class="metric-value" id="entropyVal">0.000</div>
          <div class="metric-label">Entropy</div>
        </div>
        <div class="metric-item">
          <div class="metric-value" id="energyVal">0.000</div>
          <div class="metric-label">Energy</div>
        </div>
        <div class="metric-item">
          <div class="metric-value" id="timeVal">0.000</div>
          <div class="metric-label">Time</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    class LatticePhaseFieldSim {
      constructor() {
        this.canvas = document.getElementById('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.isRunning = false;
        this.time = 0;
        
        this.settings = {
          gridSize: 64,
          diffusionRate: 0.1,
          nonlinearStrength: 0.8,
          showGrid: false,
          showTrails: false
        };
        
        this.field = null;
        this.trailBuffer = null;
        
        this.initializeField();
        this.bindControls();
        this.render();
      }
      
      initializeField() {
        const { gridSize } = this.settings;
        
        this.field = Array(gridSize).fill().map(() => 
          Array(gridSize).fill().map(() => ({
            phase: Math.random() * 2 * Math.PI,
            amplitude: Math.random() * 0.5 + 0.1
          }))
        );
        
        // Add coherent structures
>>>>>>> research-Symbolic-systems
        for (let i = 0; i < 3; i++) {
          const cx = Math.floor(Math.random() * gridSize);
          const cy = Math.floor(Math.random() * gridSize);
          const radius = Math.floor(8 + Math.random() * 12);
          
          for (let dx = -radius; dx <= radius; dx++) {
            for (let dy = -radius; dy <= radius; dy++) {
              const x = cx + dx;
              const y = cy + dy;
              const dist = Math.sqrt(dx*dx + dy*dy);
              
              if (x >= 0 && x < gridSize && y >= 0 && y < gridSize && dist <= radius) {
                const strength = Math.exp(-dist*dist / (radius*radius/4));
<<<<<<< HEAD
                newField[x][y].phase = Math.atan2(dy, dx) + Math.random() * 0.5;
                newField[x][y].amplitude = strength * (0.8 + Math.random() * 0.4);
=======
                this.field[x][y].phase = Math.atan2(dy, dx) + Math.random() * 0.5;
                this.field[x][y].amplitude = strength * (0.8 + Math.random() * 0.4);
>>>>>>> research-Symbolic-systems
              }
            }
          }
        }
        
<<<<<<< HEAD
        const newTrailBuffer = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
        
        setField(newField);
        setTrailBuffer(newTrailBuffer);
        setTime(0);
        setComplexity([]);
        setEntropy([]);
        setCircuitDepth([]);
        setEntropySpikes([]);
        setEnergyHistory([]);
        setMomentumHistory([]);
        setFourierSpectrum(null);
        setCorrelationData([]);
        setLyapunovExponent(0);
        setEvolutionHistory([]);
        setDetectedPatterns({ spirals: [], waves: [], symmetries: [], topologicalCharge: 0 });
        setPatternHistory([]);
      }, [settings.gridSize]);

      const calculateEnergyMomentum = (field, gridSize) => {
        let totalEnergy = 0;
        let totalMomentumX = 0;
        let totalMomentumY = 0;
        
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            if (!field[x]?.[y]) continue;
            const cell = field[x][y];
            
            totalEnergy += cell.phase * cell.phase + cell.amplitude * cell.amplitude;
            
            const neighbors = getNeighbors(x, y, field, gridSize);
            if (neighbors.length > 0) {
              let gradX = 0, gradY = 0;
              neighbors.forEach((neighbor, i) => {
                const dx = [1, 0, -1, 0][i] || 0;
                const dy = [0, 1, 0, -1][i] || 0;
                const phaseDiff = Math.atan2(
                  Math.sin(neighbor.phase - cell.phase), 
                  Math.cos(neighbor.phase - cell.phase)
                );
                gradX += phaseDiff * dx;
                gradY += phaseDiff * dy;
              });
              totalMomentumX += gradX * cell.amplitude;
              totalMomentumY += gradY * cell.amplitude;
            }
          }
        }
        
        return {
          energy: totalEnergy / (gridSize * gridSize),
          momentum: Math.sqrt(totalMomentumX * totalMomentumX + totalMomentumY * totalMomentumY) / (gridSize * gridSize)
        };
      };

      const calculateFourierSpectrum = (field, gridSize) => {
        if (!field || gridSize < 16) return null;
        
        const spectrum = [];
        const maxK = Math.min(8, gridSize / 4);
        
        for (let kx = 0; kx < maxK; kx++) {
          spectrum[kx] = [];
          for (let ky = 0; ky < maxK; ky++) {
            let real = 0, imag = 0;
            
            for (let x = 0; x < gridSize; x++) {
              for (let y = 0; y < gridSize; y++) {
                const phase = field[x]?.[y]?.phase || 0;
                const angle = -2 * Math.PI * (kx * x / gridSize + ky * y / gridSize);
                real += phase * Math.cos(angle);
                imag += phase * Math.sin(angle);
              }
            }
            
            spectrum[kx][ky] = Math.sqrt(real * real + imag * imag) / (gridSize * gridSize);
          }
        }
        
        return spectrum;
      };

      const calculateCorrelationFunction = (field, gridSize) => {
        if (!field) return [];
        
        const correlations = [];
        const maxDistance = Math.min(10, gridSize / 4);
        
        for (let r = 1; r <= maxDistance; r++) {
          let totalCorrelation = 0;
          let count = 0;
          
          for (let x = 0; x < gridSize - r; x++) {
            for (let y = 0; y < gridSize - r; y++) {
              const cell1 = field[x]?.[y];
              const cell2 = field[x + r]?.[y];
              if (!cell1 || !cell2) continue;
              
              const phaseDiff = Math.atan2(
                Math.sin(cell2.phase - cell1.phase), 
                Math.cos(cell2.phase - cell1.phase)
              );
              totalCorrelation += Math.cos(phaseDiff);
              count++;
            }
          }
          
          correlations.push(count > 0 ? totalCorrelation / count : 0);
        }
        
        return correlations;
      };

      const calculateLyapunovExponent = (field, gridSize) => {
        if (!field) return 0;
        
        let totalDivergence = 0;
        let count = 0;
        
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const cell = field[x]?.[y];
            if (!cell) continue;
            
            const neighbors = getNeighbors(x, y, field, gridSize);
            if (neighbors.length < 4) continue;
            
            let divergence = 0;
            neighbors.forEach((neighbor, i) => {
              const dx = [1, 0, -1, 0][i] || 0;
              const dy = [0, 1, 0, -1][i] || 0;
              const phaseGrad = Math.atan2(
                Math.sin(neighbor.phase - cell.phase), 
                Math.cos(neighbor.phase - cell.phase)
              );
              divergence += phaseGrad * (dx + dy);
            });
            
            totalDivergence += Math.abs(divergence);
            count++;
          }
        }
        
        return count > 0 ? totalDivergence / count : 0;
      };

      const detectPatterns = (field, gridSize) => {
        if (!field) return { spirals: [], waves: [], symmetries: [], topologicalCharge: 0 };
        
        const spirals = [];
        const waves = [];
        const symmetries = [];
        let topologicalCharge = 0;
        
        // Detect spirals (vortices)
        for (let x = 1; x < gridSize - 1; x++) {
          for (let y = 1; y < gridSize - 1; y++) {
            const center = field[x]?.[y];
            if (!center) continue;
            
            let windingNumber = 0;
            const neighbors = [
              field[x+1]?.[y], field[x]?.[y+1], field[x-1]?.[y], field[x]?.[y-1]
            ].filter(Boolean);
            
            if (neighbors.length === 4) {
              for (let i = 0; i < 4; i++) {
                const next = neighbors[(i + 1) % 4];
                const phaseDiff = Math.atan2(
                  Math.sin(next.phase - neighbors[i].phase), 
                  Math.cos(next.phase - neighbors[i].phase)
                );
                windingNumber += phaseDiff;
              }
              
              if (Math.abs(windingNumber) > Math.PI) {
                spirals.push({ x, y, charge: Math.sign(windingNumber) });
                topologicalCharge += Math.sign(windingNumber);
              }
            }
          }
        }
        
        // Detect waves (phase gradients)
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const cell = field[x]?.[y];
            if (!cell) continue;
            
            const neighbors = getNeighbors(x, y, field, gridSize);
            if (neighbors.length < 2) continue;
            
            let gradientMagnitude = 0;
            neighbors.forEach(neighbor => {
              const phaseDiff = Math.atan2(
                Math.sin(neighbor.phase - cell.phase), 
                Math.cos(neighbor.phase - cell.phase)
              );
              gradientMagnitude += Math.abs(phaseDiff);
            });
            
            if (gradientMagnitude > 1.0) {
              waves.push({ x, y, strength: gradientMagnitude });
            }
          }
        }
        
        // Detect symmetries (rotational)
        const centerX = Math.floor(gridSize / 2);
        const centerY = Math.floor(gridSize / 2);
        const center = field[centerX]?.[centerY];
        
        if (center) {
          let symmetryScore = 0;
          for (let angle = 0; angle < 2 * Math.PI; angle += Math.PI / 4) {
            const x1 = centerX + Math.floor(5 * Math.cos(angle));
            const y1 = centerY + Math.floor(5 * Math.sin(angle));
            const x2 = centerX + Math.floor(5 * Math.cos(angle + Math.PI));
            const y2 = centerY + Math.floor(5 * Math.sin(angle + Math.PI));
            
            const cell1 = field[x1]?.[y1];
            const cell2 = field[x2]?.[y2];
            
            if (cell1 && cell2) {
              const phaseDiff = Math.atan2(
                Math.sin(cell2.phase - cell1.phase), 
                Math.cos(cell2.phase - cell1.phase)
              );
              symmetryScore += Math.abs(phaseDiff);
            }
          }
          
          if (symmetryScore < Math.PI) {
            symmetries.push({ x: centerX, y: centerY, score: symmetryScore });
          }
        }
        
        return { spirals, waves, symmetries, topologicalCharge };
      };

      const evolveField = useCallback(() => {
        if (!field) return;
        
        const { gridSize, diffusionRate, nonlinearStrength } = settings;
        const newField = Array(gridSize).fill().map(() => 
          Array(gridSize).fill().map(() => ({ phase: 0, amplitude: 0, complexity: 0 }))
=======
        this.trailBuffer = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
      }
      
      step() {
        const { gridSize, diffusionRate, nonlinearStrength } = this.settings;
        const newField = Array(gridSize).fill().map(() => 
          Array(gridSize).fill().map(() => ({ phase: 0, amplitude: 0 }))
>>>>>>> research-Symbolic-systems
        );
        
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
<<<<<<< HEAD
            const cell = field[x]?.[y];
            if (!cell) continue;
            
            const neighbors = getNeighbors(x, y, field, gridSize);
            
            // Diffusion term
            let laplacianPhase = 0;
            let laplacianAmplitude = 0;
            
            neighbors.forEach(neighbor => {
              laplacianPhase += neighbor.phase - cell.phase;
              laplacianAmplitude += neighbor.amplitude - cell.amplitude;
            });
            
            // Nonlinear coupling
            const coupling = Math.sin(cell.phase) * cell.amplitude * nonlinearStrength;
            
            // Evolution equations
            newField[x][y].phase = cell.phase + diffusionRate * laplacianPhase + coupling;
            newField[x][y].amplitude = cell.amplitude + diffusionRate * laplacianAmplitude;
            
            // Bounds
            newField[x][y].phase = ((newField[x][y].phase % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
            newField[x][y].amplitude = Math.max(0.01, Math.min(1.0, newField[x][y].amplitude));
            
            // Complexity measure
            newField[x][y].complexity = Math.abs(laplacianPhase) + Math.abs(coupling);
          }
        }
        
        setField(newField);
        
        // Update trail buffer
        if (settings.showTrails && trailBuffer) {
          const newTrailBuffer = trailBuffer.map(row => 
            row.map(val => val * settings.trailDecay)
          );
          
          for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
              if (newField[x]?.[y]) {
                newTrailBuffer[x][y] = Math.max(newTrailBuffer[x][y], newField[x][y].complexity);
              }
            }
          }
          
          setTrailBuffer(newTrailBuffer);
        }
        
        // Analysis
        if (settings.enableAnalysis) {
          const { energy, momentum } = calculateEnergyMomentum(newField, gridSize);
          setEnergyHistory(prev => [...prev.slice(-99), energy]);
          setMomentumHistory(prev => [...prev.slice(-99), momentum]);
          
          const spectrum = calculateFourierSpectrum(newField, gridSize);
          if (spectrum) setFourierSpectrum(spectrum);
          
          const correlations = calculateCorrelationFunction(newField, gridSize);
          setCorrelationData(correlations);
          
          const lyapunov = calculateLyapunovExponent(newField, gridSize);
          setLyapunovExponent(lyapunov);
          
          const patterns = detectPatterns(newField, gridSize);
          setDetectedPatterns(patterns);
          setPatternHistory(prev => [...prev.slice(-9), patterns]);
        }
        
        // Complexity metrics
        let totalComplexity = 0;
        let totalEntropy = 0;
        let maxCircuitDepth = 0;
        
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const cell = newField[x]?.[y];
            if (!cell) continue;
            
            totalComplexity += cell.complexity;
            totalEntropy += -cell.amplitude * Math.log(cell.amplitude + 1e-10);
            maxCircuitDepth = Math.max(maxCircuitDepth, cell.complexity);
          }
        }
        
        const avgComplexity = totalComplexity / (gridSize * gridSize);
        const avgEntropy = totalEntropy / (gridSize * gridSize);
        
        setComplexity(prev => [...prev.slice(-99), avgComplexity]);
        setEntropy(prev => [...prev.slice(-99), avgEntropy]);
        setCircuitDepth(prev => [...prev.slice(-99), maxCircuitDepth]);
        
        // Entropy spikes detection
        if (avgEntropy > settings.complexityThreshold) {
          setEntropySpikes(prev => [...prev.slice(-9), { time, value: avgEntropy }]);
        }
      }, [field, settings, trailBuffer]);

      const renderCanvas = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas || !field) return;
        
        const ctx = canvas.getContext('2d');
        const { gridSize } = settings;
        
        canvas.width = 512;
        canvas.height = 512;
        
        const cellSize = canvas.width / gridSize;
        
        // Clear
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw field
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const cell = field[x]?.[y];
            if (!cell) continue;
=======
            const current = this.field[x][y];
            
            // Get neighbors
            const neighbors = [
              this.field[(x+1) % gridSize]?.[y],
              this.field[x]?.[(y+1) % gridSize],
              this.field[(x-1+gridSize) % gridSize]?.[y],
              this.field[x]?.[(y-1+gridSize) % gridSize]
            ].filter(Boolean);
            
            // Diffusion
            let avgPhase = 0;
            let avgAmplitude = 0;
            neighbors.forEach(n => {
              avgPhase += n.phase;
              avgAmplitude += n.amplitude;
            });
            avgPhase /= neighbors.length;
            avgAmplitude /= neighbors.length;
            
            // Nonlinear coupling
            const coupling = Math.sin(current.phase - avgPhase) * current.amplitude * nonlinearStrength;
            
            // Update
            newField[x][y].phase = current.phase + diffusionRate * (avgPhase - current.phase) + coupling * 0.01;
            newField[x][y].amplitude = current.amplitude + diffusionRate * (avgAmplitude - current.amplitude);
            newField[x][y].amplitude = Math.max(0.01, Math.min(1.0, newField[x][y].amplitude));
            
            // Update trails
            if (this.settings.showTrails) {
              this.trailBuffer[x][y] = this.trailBuffer[x][y] * 0.95 + current.amplitude * 0.05;
            }
          }
        }
        
        this.field = newField;
        this.time += 0.01;
        this.updateMetrics();
      }
      
      updateMetrics() {
        const { gridSize } = this.settings;
        let totalEnergy = 0;
        let totalAmplitude = 0;
        let amplitudeHist = Array(10).fill(0);
        
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const cell = this.field[x][y];
            totalEnergy += cell.amplitude * cell.amplitude;
            totalAmplitude += cell.amplitude;
            
            const bin = Math.floor(cell.amplitude * 10);
            if (bin < 10) amplitudeHist[bin]++;
          }
        }
        
        const energy = totalEnergy / (gridSize * gridSize);
        
        // Calculate entropy
        const total = amplitudeHist.reduce((a, b) => a + b, 0);
        const entropy = amplitudeHist.reduce((sum, count) => {
          if (count > 0) {
            const p = count / total;
            return sum - p * Math.log(p);
          }
          return sum;
        }, 0);
        
        const complexity = entropy * energy;
        
        document.getElementById('complexityVal').textContent = complexity.toFixed(3);
        document.getElementById('entropyVal').textContent = entropy.toFixed(3);
        document.getElementById('energyVal').textContent = energy.toFixed(3);
        document.getElementById('timeVal').textContent = this.time.toFixed(2);
      }
      
      render() {
        const { gridSize, showGrid, showTrails } = this.settings;
        const cellSize = this.canvas.width / gridSize;
        
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const cell = this.field[x][y];
            const trail = this.trailBuffer[x][y];
            
            const hue = (cell.phase / (2 * Math.PI)) * 360;
            const saturation = 80;
            const lightness = Math.min(90, 20 + cell.amplitude * 70);
            
            this.ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
>>>>>>> research-Symbolic-systems
            
            const px = x * cellSize;
            const py = y * cellSize;
            
<<<<<<< HEAD
            // Color based on phase
            const hue = (cell.phase / (2 * Math.PI)) * 360;
            const saturation = 80;
            const lightness = 30 + cell.amplitude * 40;
            
            ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            ctx.fillRect(px, py, cellSize, cellSize);
            
            // Trail overlay
            if (settings.showTrails && trailBuffer) {
              const trailValue = trailBuffer[x]?.[y] || 0;
              if (trailValue > 0.01) {
                ctx.fillStyle = `rgba(255, 255, 255, ${trailValue * 0.3})`;
                ctx.fillRect(px, py, cellSize, cellSize);
              }
=======
            this.ctx.fillRect(px, py, cellSize, cellSize);
            
            if (showTrails && trail > 0.01) {
              this.ctx.fillStyle = `rgba(255, 255, 255, ${trail * 0.3})`;
              this.ctx.fillRect(px, py, cellSize, cellSize);
>>>>>>> research-Symbolic-systems
            }
          }
        }
        
<<<<<<< HEAD
        // Grid overlay
        if (settings.showGrid) {
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.lineWidth = 1;
          
          for (let i = 0; i <= gridSize; i++) {
            const pos = i * cellSize;
            ctx.beginPath();
            ctx.moveTo(pos, 0);
            ctx.lineTo(pos, canvas.height);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, pos);
            ctx.lineTo(canvas.width, pos);
            ctx.stroke();
          }
        }
        
        // Pattern overlays
        if (settings.showPatterns) {
          // Spirals
          detectedPatterns.spirals.forEach(spiral => {
            const px = spiral.x * cellSize + cellSize / 2;
            const py = spiral.y * cellSize + cellSize / 2;
            
            ctx.fillStyle = spiral.charge > 0 ? 'rgba(255, 0, 0, 0.7)' : 'rgba(0, 0, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(px, py, cellSize / 3, 0, 2 * Math.PI);
            ctx.fill();
          });
          
          // Waves
          detectedPatterns.waves.forEach(wave => {
            const px = wave.x * cellSize + cellSize / 2;
            const py = wave.y * cellSize + cellSize / 2;
            
            ctx.strokeStyle = `rgba(0, 255, 0, ${Math.min(0.8, wave.strength / 2)})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(px, py, cellSize / 2, 0, 2 * Math.PI);
            ctx.stroke();
          });
          
          // Symmetries
          detectedPatterns.symmetries.forEach(symmetry => {
            const px = symmetry.x * cellSize + cellSize / 2;
            const py = symmetry.y * cellSize + cellSize / 2;
            
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(px, py, cellSize, 0, 2 * Math.PI);
            ctx.stroke();
          });
        }
      }, [field, settings, trailBuffer, detectedPatterns]);

      // Animation loop
      useEffect(() => {
        if (isRunning) {
          evolveField();
          setTime(t => t + 0.016);
        }
      }, [isRunning, evolveField]);

      // Render canvas
      useEffect(() => {
        renderCanvas();
      }, [renderCanvas]);

      // Initialize
      useEffect(() => {
        initializeField();
      }, [initializeField]);

      return (
        <div className="container">
          <div className="panel" style={{marginBottom:12}}>
            <h1>üåä Lattice Phase Field Simulation</h1>
            <p>Quantum-inspired symbolic field dynamics on a discrete lattice with mathematical analysis.</p>
            <div style={{ display:'flex', gap:8, alignItems:'center', flexWrap:'wrap', marginTop:8 }}>
              <button onClick={()=>setIsRunning(r=>!r)}>{isRunning? 'Pause':'Play'}</button>
              <button onClick={initializeField}>Reset</button>
              <span>t = {time.toFixed(2)}s</span>
              <span>Grid: {settings.gridSize}¬≤</span>
            </div>
          </div>
          
          <div style={{ display:'grid', gridTemplateColumns:'1fr 300px', gap:12 }}>
            <div className="panel">
              <canvas ref={canvasRef} style={{ width:'100%', height:'512px', border:'1px solid #333', borderRadius:8 }} />
            </div>
            
            <div style={{ display:'flex', flexDirection:'column', gap:12 }}>
              <div className="panel">
                <h3>Controls</h3>
                <div style={{ fontSize:12 }}>
                  <label>Grid Size
                    <select value={settings.gridSize} onChange={e=>setSettings(s=>({...s, gridSize:parseInt(e.target.value)}))}>
                      <option value={32}>32¬≤ (Fast)</option>
                      <option value={64}>64¬≤ (Good)</option>
                      <option value={128}>128¬≤ (High)</option>
                    </select>
                  </label>
                  <label>Diffusion Rate
                    <input type="range" min="0.01" max="0.3" step="0.01" value={settings.diffusionRate} onChange={e=>setSettings(s=>({...s, diffusionRate:parseFloat(e.target.value)}))} />
                  </label>
                  <label>Nonlinear Strength
                    <input type="range" min="0.1" max="2" step="0.1" value={settings.nonlinearStrength} onChange={e=>setSettings(s=>({...s, nonlinearStrength:parseFloat(e.target.value)}))} />
                  </label>
                  <label>Complexity Threshold
                    <input type="range" min="0.1" max="2" step="0.1" value={settings.complexityThreshold} onChange={e=>setSettings(s=>({...s, complexityThreshold:parseFloat(e.target.value)}))} />
                  </label>
                </div>
              </div>
              
              <div className="panel">
                <h3>Visualization</h3>
                <div style={{ fontSize:12 }}>
                  <label><input type="checkbox" checked={settings.showGrid} onChange={e=>setSettings(s=>({...s, showGrid:e.target.checked}))} /> Show Grid</label>
                  <label><input type="checkbox" checked={settings.showTrails} onChange={e=>setSettings(s=>({...s, showTrails:e.target.checked}))} /> Show Trails</label>
                  <label><input type="checkbox" checked={settings.showPatterns} onChange={e=>setSettings(s=>({...s, showPatterns:e.target.checked}))} /> Show Patterns</label>
                  {settings.showTrails && (
                    <label>Trail Decay
                      <input type="range" min="0.8" max="0.99" step="0.01" value={settings.trailDecay} onChange={e=>setSettings(s=>({...s, trailDecay:parseFloat(e.target.value)}))} />
                    </label>
                  )}
                </div>
              </div>
              
              <div className="panel">
                <h3>Analysis</h3>
                <div style={{ fontSize:12 }}>
                  <label><input type="checkbox" checked={settings.enableAnalysis} onChange={e=>setSettings(s=>({...s, enableAnalysis:e.target.checked}))} /> Enable Analysis</label>
                  {settings.enableAnalysis && (
                    <label>Mode
                      <select value={settings.analysisMode} onChange={e=>setSettings(s=>({...s, analysisMode:e.target.value}))}>
                        <option value="energy">Energy</option>
                        <option value="fourier">Fourier</option>
                        <option value="correlation">Correlation</option>
                        <option value="lyapunov">Chaos</option>
                        <option value="patterns">Patterns</option>
                      </select>
                    </label>
                  )}
                </div>
              </div>
              
              <div className="panel">
                <h3>Metrics</h3>
                <div style={{ fontSize:12 }}>
                  <div>Complexity: <code>{complexity[complexity.length-1]?.toFixed(3) || '0.000'}</code></div>
                  <div>Entropy: <code>{entropy[entropy.length-1]?.toFixed(3) || '0.000'}</code></div>
                  <div>Circuit Depth: <code>{circuitDepth[circuitDepth.length-1]?.toFixed(3) || '0.000'}</code></div>
                  <div>Topological Charge: <code>{detectedPatterns.topologicalCharge}</code></div>
                  <div>Lyapunov: <code>{lyapunovExponent.toFixed(3)}</code></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<QuantumSymbolicComplexity />);
=======
        if (showGrid) {
          this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
          this.ctx.lineWidth = 1;
          
          for (let x = 0; x <= gridSize; x++) {
            this.ctx.beginPath();
            this.ctx.moveTo(x * cellSize, 0);
            this.ctx.lineTo(x * cellSize, this.canvas.height);
            this.ctx.stroke();
          }
          
          for (let y = 0; y <= gridSize; y++) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y * cellSize);
            this.ctx.lineTo(this.canvas.width, y * cellSize);
            this.ctx.stroke();
          }
        }
      }
      
      bindControls() {
        document.getElementById('playBtn').onclick = () => this.start();
        document.getElementById('pauseBtn').onclick = () => this.stop();
        document.getElementById('resetBtn').onclick = () => this.reset();
        
        const sliders = ['gridSize', 'diffusionRate', 'nonlinearStrength'];
        sliders.forEach(id => {
          const slider = document.getElementById(id);
          const display = document.getElementById(id + 'Val');
          
          slider.oninput = (e) => {
            this.settings[id] = parseFloat(e.target.value);
            display.textContent = e.target.value;
            if (id === 'gridSize') {
              this.initializeField();
            }
          };
        });
        
        document.getElementById('showGrid').onchange = (e) => {
          this.settings.showGrid = e.target.checked;
        };
        
        document.getElementById('showTrails').onchange = (e) => {
          this.settings.showTrails = e.target.checked;
        };
      }
      
      start() {
        if (!this.isRunning) {
          this.isRunning = true;
          this.animate();
        }
      }
      
      stop() {
        this.isRunning = false;
      }
      
      reset() {
        this.stop();
        this.time = 0;
        this.initializeField();
        this.updateMetrics();
        this.render();
      }
      
      animate() {
        if (this.isRunning) {
          this.step();
          this.render();
          requestAnimationFrame(() => this.animate());
        }
      }
    }
    
    window.addEventListener('load', () => {
      new LatticePhaseFieldSim();
    });
>>>>>>> research-Symbolic-systems
  </script>
</body>
</html>
