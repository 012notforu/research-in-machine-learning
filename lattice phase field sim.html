<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lattice Phase Field Simulation</title>
  <link rel="icon" href="data:," />
  <style>
    html, body, #root { height: 100%; margin: 0 }
    body { background: #0a0a0f; color: #e1e8f0; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif }
    .container { max-width: 1200px; margin: 0 auto; padding: 16px }
    .panel { background:#12121a; border:1px solid rgba(255,255,255,0.08); border-radius:12px; padding:12px }
    .controls input, .controls select { width: 100% }
  </style>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    const QuantumSymbolicComplexity = () => {
      const canvasRef = useRef(null);
      const animationRef = useRef(null);
      
      const [isRunning, setIsRunning] = useState(false);
      const [time, setTime] = useState(0);
      const [field, setField] = useState(null);
      const [trailBuffer, setTrailBuffer] = useState(null);
      
      const [settings, setSettings] = useState({
        gridSize: 64,
        diffusionRate: 0.1,
        nonlinearStrength: 0.8,
        complexityThreshold: 0.7,
        showGrid: false,
        showTrails: false,
        trailDecay: 0.95,
        enableAnalysis: false,
        analysisMode: 'energy',
        showPatterns: false
      });
      
      const [complexity, setComplexity] = useState([]);
      const [entropy, setEntropy] = useState([]);
      const [circuitDepth, setCircuitDepth] = useState([]);
      const [entropySpikes, setEntropySpikes] = useState([]);
      
      const [energyHistory, setEnergyHistory] = useState([]);
      const [momentumHistory, setMomentumHistory] = useState([]);
      const [fourierSpectrum, setFourierSpectrum] = useState(null);
      const [correlationData, setCorrelationData] = useState([]);
      const [lyapunovExponent, setLyapunovExponent] = useState(0);
      const [evolutionHistory, setEvolutionHistory] = useState([]);
      
      const [detectedPatterns, setDetectedPatterns] = useState({
        spirals: [],
        waves: [],
        symmetries: [],
        topologicalCharge: 0
      });
      const [patternHistory, setPatternHistory] = useState([]);

      const getNeighbors = (x, y, grid, gridSize) => {
        return [
          grid[(x+1) % gridSize]?.[y],
          grid[x]?.[(y+1) % gridSize],
          grid[(x-1+gridSize) % gridSize]?.[y],
          grid[x]?.[(y-1+gridSize) % gridSize]
        ].filter(Boolean);
      };

      const initializeField = useCallback(() => {
        const { gridSize } = settings;
        
        const newField = Array(gridSize).fill().map(() => 
          Array(gridSize).fill().map(() => ({
            phase: Math.random() * 2 * Math.PI,
            amplitude: Math.random() * 0.5 + 0.1,
            complexity: 0
          }))
        );
        
        for (let i = 0; i < 3; i++) {
          const cx = Math.floor(Math.random() * gridSize);
          const cy = Math.floor(Math.random() * gridSize);
          const radius = Math.floor(8 + Math.random() * 12);
          
          for (let dx = -radius; dx <= radius; dx++) {
            for (let dy = -radius; dy <= radius; dy++) {
              const x = cx + dx;
              const y = cy + dy;
              const dist = Math.sqrt(dx*dx + dy*dy);
              
              if (x >= 0 && x < gridSize && y >= 0 && y < gridSize && dist <= radius) {
                const strength = Math.exp(-dist*dist / (radius*radius/4));
                newField[x][y].phase = Math.atan2(dy, dx) + Math.random() * 0.5;
                newField[x][y].amplitude = strength * (0.8 + Math.random() * 0.4);
              }
            }
          }
        }
        
        const newTrailBuffer = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
        
        setField(newField);
        setTrailBuffer(newTrailBuffer);
        setTime(0);
        setComplexity([]);
        setEntropy([]);
        setCircuitDepth([]);
        setEntropySpikes([]);
        setEnergyHistory([]);
        setMomentumHistory([]);
        setFourierSpectrum(null);
        setCorrelationData([]);
        setLyapunovExponent(0);
        setEvolutionHistory([]);
        setDetectedPatterns({ spirals: [], waves: [], symmetries: [], topologicalCharge: 0 });
        setPatternHistory([]);
      }, [settings.gridSize]);

      const calculateEnergyMomentum = (field, gridSize) => {
        let totalEnergy = 0;
        let totalMomentumX = 0;
        let totalMomentumY = 0;
        
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            if (!field[x]?.[y]) continue;
            const cell = field[x][y];
            
            totalEnergy += cell.phase * cell.phase + cell.amplitude * cell.amplitude;
            
            const neighbors = getNeighbors(x, y, field, gridSize);
            if (neighbors.length > 0) {
              let gradX = 0, gradY = 0;
              neighbors.forEach((neighbor, i) => {
                const dx = [1, 0, -1, 0][i] || 0;
                const dy = [0, 1, 0, -1][i] || 0;
                const phaseDiff = Math.atan2(
                  Math.sin(neighbor.phase - cell.phase), 
                  Math.cos(neighbor.phase - cell.phase)
                );
                gradX += phaseDiff * dx;
                gradY += phaseDiff * dy;
              });
              totalMomentumX += gradX * cell.amplitude;
              totalMomentumY += gradY * cell.amplitude;
            }
          }
        }
        
        return {
          energy: totalEnergy / (gridSize * gridSize),
          momentum: Math.sqrt(totalMomentumX * totalMomentumX + totalMomentumY * totalMomentumY) / (gridSize * gridSize)
        };
      };

      const calculateFourierSpectrum = (field, gridSize) => {
        if (!field || gridSize < 16) return null;
        
        const spectrum = [];
        const maxK = Math.min(8, gridSize / 4);
        
        for (let kx = 0; kx < maxK; kx++) {
          spectrum[kx] = [];
          for (let ky = 0; ky < maxK; ky++) {
            let real = 0, imag = 0;
            
            for (let x = 0; x < gridSize; x++) {
              for (let y = 0; y < gridSize; y++) {
                const phase = field[x]?.[y]?.phase || 0;
                const angle = -2 * Math.PI * (kx * x / gridSize + ky * y / gridSize);
                real += phase * Math.cos(angle);
                imag += phase * Math.sin(angle);
              }
            }
            
            spectrum[kx][ky] = Math.sqrt(real * real + imag * imag) / (gridSize * gridSize);
          }
        }
        
        return spectrum;
      };

      const calculateCorrelationFunction = (field, gridSize) => {
        if (!field) return [];
        
        const correlations = [];
        const maxDistance = Math.min(10, gridSize / 4);
        
        for (let r = 1; r <= maxDistance; r++) {
          let totalCorrelation = 0;
          let count = 0;
          
          for (let x = 0; x < gridSize - r; x++) {
            for (let y = 0; y < gridSize - r; y++) {
              const cell1 = field[x]?.[y];
              const cell2 = field[x + r]?.[y];
              if (!cell1 || !cell2) continue;
              
              const phaseDiff = Math.atan2(
                Math.sin(cell2.phase - cell1.phase), 
                Math.cos(cell2.phase - cell1.phase)
              );
              totalCorrelation += Math.cos(phaseDiff);
              count++;
            }
          }
          
          correlations.push(count > 0 ? totalCorrelation / count : 0);
        }
        
        return correlations;
      };

      const calculateLyapunovExponent = (field, gridSize) => {
        if (!field) return 0;
        
        let totalDivergence = 0;
        let count = 0;
        
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const cell = field[x]?.[y];
            if (!cell) continue;
            
            const neighbors = getNeighbors(x, y, field, gridSize);
            if (neighbors.length < 4) continue;
            
            let divergence = 0;
            neighbors.forEach((neighbor, i) => {
              const dx = [1, 0, -1, 0][i] || 0;
              const dy = [0, 1, 0, -1][i] || 0;
              const phaseGrad = Math.atan2(
                Math.sin(neighbor.phase - cell.phase), 
                Math.cos(neighbor.phase - cell.phase)
              );
              divergence += phaseGrad * (dx + dy);
            });
            
            totalDivergence += Math.abs(divergence);
            count++;
          }
        }
        
        return count > 0 ? totalDivergence / count : 0;
      };

      const detectPatterns = (field, gridSize) => {
        if (!field) return { spirals: [], waves: [], symmetries: [], topologicalCharge: 0 };
        
        const spirals = [];
        const waves = [];
        const symmetries = [];
        let topologicalCharge = 0;
        
        // Detect spirals (vortices)
        for (let x = 1; x < gridSize - 1; x++) {
          for (let y = 1; y < gridSize - 1; y++) {
            const center = field[x]?.[y];
            if (!center) continue;
            
            let windingNumber = 0;
            const neighbors = [
              field[x+1]?.[y], field[x]?.[y+1], field[x-1]?.[y], field[x]?.[y-1]
            ].filter(Boolean);
            
            if (neighbors.length === 4) {
              for (let i = 0; i < 4; i++) {
                const next = neighbors[(i + 1) % 4];
                const phaseDiff = Math.atan2(
                  Math.sin(next.phase - neighbors[i].phase), 
                  Math.cos(next.phase - neighbors[i].phase)
                );
                windingNumber += phaseDiff;
              }
              
              if (Math.abs(windingNumber) > Math.PI) {
                spirals.push({ x, y, charge: Math.sign(windingNumber) });
                topologicalCharge += Math.sign(windingNumber);
              }
            }
          }
        }
        
        // Detect waves (phase gradients)
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const cell = field[x]?.[y];
            if (!cell) continue;
            
            const neighbors = getNeighbors(x, y, field, gridSize);
            if (neighbors.length < 2) continue;
            
            let gradientMagnitude = 0;
            neighbors.forEach(neighbor => {
              const phaseDiff = Math.atan2(
                Math.sin(neighbor.phase - cell.phase), 
                Math.cos(neighbor.phase - cell.phase)
              );
              gradientMagnitude += Math.abs(phaseDiff);
            });
            
            if (gradientMagnitude > 1.0) {
              waves.push({ x, y, strength: gradientMagnitude });
            }
          }
        }
        
        // Detect symmetries (rotational)
        const centerX = Math.floor(gridSize / 2);
        const centerY = Math.floor(gridSize / 2);
        const center = field[centerX]?.[centerY];
        
        if (center) {
          let symmetryScore = 0;
          for (let angle = 0; angle < 2 * Math.PI; angle += Math.PI / 4) {
            const x1 = centerX + Math.floor(5 * Math.cos(angle));
            const y1 = centerY + Math.floor(5 * Math.sin(angle));
            const x2 = centerX + Math.floor(5 * Math.cos(angle + Math.PI));
            const y2 = centerY + Math.floor(5 * Math.sin(angle + Math.PI));
            
            const cell1 = field[x1]?.[y1];
            const cell2 = field[x2]?.[y2];
            
            if (cell1 && cell2) {
              const phaseDiff = Math.atan2(
                Math.sin(cell2.phase - cell1.phase), 
                Math.cos(cell2.phase - cell1.phase)
              );
              symmetryScore += Math.abs(phaseDiff);
            }
          }
          
          if (symmetryScore < Math.PI) {
            symmetries.push({ x: centerX, y: centerY, score: symmetryScore });
          }
        }
        
        return { spirals, waves, symmetries, topologicalCharge };
      };

      const evolveField = useCallback(() => {
        if (!field) return;
        
        const { gridSize, diffusionRate, nonlinearStrength } = settings;
        const newField = Array(gridSize).fill().map(() => 
          Array(gridSize).fill().map(() => ({ phase: 0, amplitude: 0, complexity: 0 }))
        );
        
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const cell = field[x]?.[y];
            if (!cell) continue;
            
            const neighbors = getNeighbors(x, y, field, gridSize);
            
            // Diffusion term
            let laplacianPhase = 0;
            let laplacianAmplitude = 0;
            
            neighbors.forEach(neighbor => {
              laplacianPhase += neighbor.phase - cell.phase;
              laplacianAmplitude += neighbor.amplitude - cell.amplitude;
            });
            
            // Nonlinear coupling
            const coupling = Math.sin(cell.phase) * cell.amplitude * nonlinearStrength;
            
            // Evolution equations
            newField[x][y].phase = cell.phase + diffusionRate * laplacianPhase + coupling;
            newField[x][y].amplitude = cell.amplitude + diffusionRate * laplacianAmplitude;
            
            // Bounds
            newField[x][y].phase = ((newField[x][y].phase % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
            newField[x][y].amplitude = Math.max(0.01, Math.min(1.0, newField[x][y].amplitude));
            
            // Complexity measure
            newField[x][y].complexity = Math.abs(laplacianPhase) + Math.abs(coupling);
          }
        }
        
        setField(newField);
        
        // Update trail buffer
        if (settings.showTrails && trailBuffer) {
          const newTrailBuffer = trailBuffer.map(row => 
            row.map(val => val * settings.trailDecay)
          );
          
          for (let x = 0; x < gridSize; x++) {
            for (let y = 0; y < gridSize; y++) {
              if (newField[x]?.[y]) {
                newTrailBuffer[x][y] = Math.max(newTrailBuffer[x][y], newField[x][y].complexity);
              }
            }
          }
          
          setTrailBuffer(newTrailBuffer);
        }
        
        // Analysis
        if (settings.enableAnalysis) {
          const { energy, momentum } = calculateEnergyMomentum(newField, gridSize);
          setEnergyHistory(prev => [...prev.slice(-99), energy]);
          setMomentumHistory(prev => [...prev.slice(-99), momentum]);
          
          const spectrum = calculateFourierSpectrum(newField, gridSize);
          if (spectrum) setFourierSpectrum(spectrum);
          
          const correlations = calculateCorrelationFunction(newField, gridSize);
          setCorrelationData(correlations);
          
          const lyapunov = calculateLyapunovExponent(newField, gridSize);
          setLyapunovExponent(lyapunov);
          
          const patterns = detectPatterns(newField, gridSize);
          setDetectedPatterns(patterns);
          setPatternHistory(prev => [...prev.slice(-9), patterns]);
        }
        
        // Complexity metrics
        let totalComplexity = 0;
        let totalEntropy = 0;
        let maxCircuitDepth = 0;
        
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const cell = newField[x]?.[y];
            if (!cell) continue;
            
            totalComplexity += cell.complexity;
            totalEntropy += -cell.amplitude * Math.log(cell.amplitude + 1e-10);
            maxCircuitDepth = Math.max(maxCircuitDepth, cell.complexity);
          }
        }
        
        const avgComplexity = totalComplexity / (gridSize * gridSize);
        const avgEntropy = totalEntropy / (gridSize * gridSize);
        
        setComplexity(prev => [...prev.slice(-99), avgComplexity]);
        setEntropy(prev => [...prev.slice(-99), avgEntropy]);
        setCircuitDepth(prev => [...prev.slice(-99), maxCircuitDepth]);
        
        // Entropy spikes detection
        if (avgEntropy > settings.complexityThreshold) {
          setEntropySpikes(prev => [...prev.slice(-9), { time, value: avgEntropy }]);
        }
      }, [field, settings, trailBuffer]);

      const renderCanvas = useCallback(() => {
        const canvas = canvasRef.current;
        if (!canvas || !field) return;
        
        const ctx = canvas.getContext('2d');
        const { gridSize } = settings;
        
        canvas.width = 512;
        canvas.height = 512;
        
        const cellSize = canvas.width / gridSize;
        
        // Clear
        ctx.fillStyle = '#0a0a0f';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw field
        for (let x = 0; x < gridSize; x++) {
          for (let y = 0; y < gridSize; y++) {
            const cell = field[x]?.[y];
            if (!cell) continue;
            
            const px = x * cellSize;
            const py = y * cellSize;
            
            // Color based on phase
            const hue = (cell.phase / (2 * Math.PI)) * 360;
            const saturation = 80;
            const lightness = 30 + cell.amplitude * 40;
            
            ctx.fillStyle = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
            ctx.fillRect(px, py, cellSize, cellSize);
            
            // Trail overlay
            if (settings.showTrails && trailBuffer) {
              const trailValue = trailBuffer[x]?.[y] || 0;
              if (trailValue > 0.01) {
                ctx.fillStyle = `rgba(255, 255, 255, ${trailValue * 0.3})`;
                ctx.fillRect(px, py, cellSize, cellSize);
              }
            }
          }
        }
        
        // Grid overlay
        if (settings.showGrid) {
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.lineWidth = 1;
          
          for (let i = 0; i <= gridSize; i++) {
            const pos = i * cellSize;
            ctx.beginPath();
            ctx.moveTo(pos, 0);
            ctx.lineTo(pos, canvas.height);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, pos);
            ctx.lineTo(canvas.width, pos);
            ctx.stroke();
          }
        }
        
        // Pattern overlays
        if (settings.showPatterns) {
          // Spirals
          detectedPatterns.spirals.forEach(spiral => {
            const px = spiral.x * cellSize + cellSize / 2;
            const py = spiral.y * cellSize + cellSize / 2;
            
            ctx.fillStyle = spiral.charge > 0 ? 'rgba(255, 0, 0, 0.7)' : 'rgba(0, 0, 255, 0.7)';
            ctx.beginPath();
            ctx.arc(px, py, cellSize / 3, 0, 2 * Math.PI);
            ctx.fill();
          });
          
          // Waves
          detectedPatterns.waves.forEach(wave => {
            const px = wave.x * cellSize + cellSize / 2;
            const py = wave.y * cellSize + cellSize / 2;
            
            ctx.strokeStyle = `rgba(0, 255, 0, ${Math.min(0.8, wave.strength / 2)})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(px, py, cellSize / 2, 0, 2 * Math.PI);
            ctx.stroke();
          });
          
          // Symmetries
          detectedPatterns.symmetries.forEach(symmetry => {
            const px = symmetry.x * cellSize + cellSize / 2;
            const py = symmetry.y * cellSize + cellSize / 2;
            
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(px, py, cellSize, 0, 2 * Math.PI);
            ctx.stroke();
          });
        }
      }, [field, settings, trailBuffer, detectedPatterns]);

      // Animation loop
      useEffect(() => {
        if (isRunning) {
          evolveField();
          setTime(t => t + 0.016);
        }
      }, [isRunning, evolveField]);

      // Render canvas
      useEffect(() => {
        renderCanvas();
      }, [renderCanvas]);

      // Initialize
      useEffect(() => {
        initializeField();
      }, [initializeField]);

      return (
        <div className="container">
          <div className="panel" style={{marginBottom:12}}>
            <h1>🌊 Lattice Phase Field Simulation</h1>
            <p>Quantum-inspired symbolic field dynamics on a discrete lattice with mathematical analysis.</p>
            <div style={{ display:'flex', gap:8, alignItems:'center', flexWrap:'wrap', marginTop:8 }}>
              <button onClick={()=>setIsRunning(r=>!r)}>{isRunning? 'Pause':'Play'}</button>
              <button onClick={initializeField}>Reset</button>
              <span>t = {time.toFixed(2)}s</span>
              <span>Grid: {settings.gridSize}²</span>
            </div>
          </div>
          
          <div style={{ display:'grid', gridTemplateColumns:'1fr 300px', gap:12 }}>
            <div className="panel">
              <canvas ref={canvasRef} style={{ width:'100%', height:'512px', border:'1px solid #333', borderRadius:8 }} />
            </div>
            
            <div style={{ display:'flex', flexDirection:'column', gap:12 }}>
              <div className="panel">
                <h3>Controls</h3>
                <div style={{ fontSize:12 }}>
                  <label>Grid Size
                    <select value={settings.gridSize} onChange={e=>setSettings(s=>({...s, gridSize:parseInt(e.target.value)}))}>
                      <option value={32}>32² (Fast)</option>
                      <option value={64}>64² (Good)</option>
                      <option value={128}>128² (High)</option>
                    </select>
                  </label>
                  <label>Diffusion Rate
                    <input type="range" min="0.01" max="0.3" step="0.01" value={settings.diffusionRate} onChange={e=>setSettings(s=>({...s, diffusionRate:parseFloat(e.target.value)}))} />
                  </label>
                  <label>Nonlinear Strength
                    <input type="range" min="0.1" max="2" step="0.1" value={settings.nonlinearStrength} onChange={e=>setSettings(s=>({...s, nonlinearStrength:parseFloat(e.target.value)}))} />
                  </label>
                  <label>Complexity Threshold
                    <input type="range" min="0.1" max="2" step="0.1" value={settings.complexityThreshold} onChange={e=>setSettings(s=>({...s, complexityThreshold:parseFloat(e.target.value)}))} />
                  </label>
                </div>
              </div>
              
              <div className="panel">
                <h3>Visualization</h3>
                <div style={{ fontSize:12 }}>
                  <label><input type="checkbox" checked={settings.showGrid} onChange={e=>setSettings(s=>({...s, showGrid:e.target.checked}))} /> Show Grid</label>
                  <label><input type="checkbox" checked={settings.showTrails} onChange={e=>setSettings(s=>({...s, showTrails:e.target.checked}))} /> Show Trails</label>
                  <label><input type="checkbox" checked={settings.showPatterns} onChange={e=>setSettings(s=>({...s, showPatterns:e.target.checked}))} /> Show Patterns</label>
                  {settings.showTrails && (
                    <label>Trail Decay
                      <input type="range" min="0.8" max="0.99" step="0.01" value={settings.trailDecay} onChange={e=>setSettings(s=>({...s, trailDecay:parseFloat(e.target.value)}))} />
                    </label>
                  )}
                </div>
              </div>
              
              <div className="panel">
                <h3>Analysis</h3>
                <div style={{ fontSize:12 }}>
                  <label><input type="checkbox" checked={settings.enableAnalysis} onChange={e=>setSettings(s=>({...s, enableAnalysis:e.target.checked}))} /> Enable Analysis</label>
                  {settings.enableAnalysis && (
                    <label>Mode
                      <select value={settings.analysisMode} onChange={e=>setSettings(s=>({...s, analysisMode:e.target.value}))}>
                        <option value="energy">Energy</option>
                        <option value="fourier">Fourier</option>
                        <option value="correlation">Correlation</option>
                        <option value="lyapunov">Chaos</option>
                        <option value="patterns">Patterns</option>
                      </select>
                    </label>
                  )}
                </div>
              </div>
              
              <div className="panel">
                <h3>Metrics</h3>
                <div style={{ fontSize:12 }}>
                  <div>Complexity: <code>{complexity[complexity.length-1]?.toFixed(3) || '0.000'}</code></div>
                  <div>Entropy: <code>{entropy[entropy.length-1]?.toFixed(3) || '0.000'}</code></div>
                  <div>Circuit Depth: <code>{circuitDepth[circuitDepth.length-1]?.toFixed(3) || '0.000'}</code></div>
                  <div>Topological Charge: <code>{detectedPatterns.topologicalCharge}</code></div>
                  <div>Lyapunov: <code>{lyapunovExponent.toFixed(3)}</code></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<QuantumSymbolicComplexity />);
  </script>
</body>
</html>
